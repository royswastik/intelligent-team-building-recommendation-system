Proceedings of the 10th International Workshop on Finite State Methods and Natural Language Processing, pages 55?59,
Donostia?San Sebastia?n, July 23?25, 2012. c?2012 Association for Computational Linguistics
Implementation of replace rules using preference operator 
Senka Drobac, Miikka Silfverberg, and Anssi Yli-Jyr?  University of Helsinki Department of Modern Languages Unioninkatu 40 A FI-00014 Helsingin yliopisto, Finland {senka.drobac, miikka.silfverberg, anssi.yli-jyra}@helsinki.fi  Abstract 
We explain the implementation of replace rules with the .r-glc. operator and preference relations. Our modular approach combines various preference constraints to form differ-ent replace rules. In addition to describing the method, we present illustrative examples. 1 Introduction The idea of HFST - Helsinki Finite-State Technol-ogy (Lind?n et al 2009, 2011) is to provide open-source replicas of well-known tools for building morphologies, including XFST (Beesley and Kart-tunen 2003). HFST's lack of replace rules such as those supported by XFST, prompted us to imple-ment them using the present method, which repli-cates XFST's behavior (with minor differences which will be detailed in later work), but will also allow easy expansion with new functionalities. The semantics of replacement rules mixes con-textual conditions with replacement strategies that are specified by replace rule operators. This paper describes the implementation of replace rules using a preference operator, .r-glc., that disambiguates alternative replacement strategies according to a preference relation. The use of preference relations (Yli-Jyr? 2008b) is similar to the worsener rela-tions used by Gerdemann (2009). The current ap-proach was first described in Yli-Jyr? (2008b), and is closely related to the matching-based finite-state approaches to optimality in OT phonology (Noord and Gerdemann 1999; Eisner 2000). The prefer-ence operator, .r-glc., is the reversal of generalized lenient composition (glc), a preference operator construct proposed by J?ger (2001). The imple-mentation is developed using the HFST library, and is now a part of the same. 
The purpose of this paper is to explain a general method of compiling replace rules with .r-glc. operator and to show how preference constraints described in Yli-Jyr? (2008b) can be combined to form different replace rules. 2 Notation The notation used in this paper is the standard reg-ular expression notation extended with replace rule operators introduced and described in Beesley and Karttunen (2003). In a simple rule ? ??? ?? ???? ??? ?_ ???,? , ?? ?_ ??? op is a replace rule operator such as: ?, ? , ?@?, ?@>, ?, (?), ?; ? ?  ???  is the set of patterns in the input text that are overwritten in the output text by the alternative patterns, which are given as set ? ?  ???, where ?? is a universal language and ?? set of alphabetical symbols; ?? and ?? are left and right contexts and dir is context direction (||, //, \\ and \/). Rules can also be parallel. Then they are divid-ed with double comma (,,), or alternately with sin-gle comma if context is not specified. Operation Name X Y The concatenation of Y after X X | Y The disjunction of X and Y X:Y The cross product of X and Y, where X and Y denote languages X .o. Y The composition of X and Y, where X and Y denote relations X+ The Kleene plus X* The Kleene star proj1(X) The projection of the input lan-guage of the relation X proj2(X) The projection of the output lan-guage of the relation X Table 1 ? List of operations 
55
Operators used in the paper are listed in Table 1, where X and Y stand for regular expressions. Additionally, parenthesis ( ) are used to mark optionality, squared brackets [ ] for precedence and question mark ? is used to denote set ? in regular expressions. 3 Method The general idea for compiling replace rules with the .r-glc. operator and preference constraints is shown in Figure 1. 
 Figure 1: General method of building a replace rule  The method consists of the following steps: 1. Building an Unconstrained Bracketed Transducer (UBT) ? a transducer which applies or skips contextually valid re-placements freely in all possible portions of the inputs.  Every application of the re-placement rule is marked with special brackets. Similar replace rules that differ only with respect to their replacement strategies will use the same UBT. Thus, the compilation of UBT is independent of the replacement strategy, which increases the modularity of the compilation algo-rithm. 2. Implement the functionality of the replace rule operator by constraining the UBT with the respective preference relation. 3. Remove brackets from the transducer.  The major advantage of this method is its mod-ularity. The algorithm is divided into small com-ponents which are combined in the desired way. This approach allows every part of the algorithm to be separately and clearly defined, tested and 
changed. Furthermore, modularity makes it possi-ble to easily integrate new functionalities such as weighted replace rules or two level contexts. 3.1 Unconstrained Bracketed Transducer As mentioned earlier, it is first necessary to build the UBT. This step can be seen as a variant of Yli-Jyr? and Koskenniemi's (2007) method for compil-ing contextually restricted changes in two-level grammars.  The main difference now is that the rule applications cannot overlap because they will be marked with brackets.  Step 1: Bracketed center The first step is to create a bracketed center, ???????  ? the replace relation surrounded by brackets , . For optional replacement, it is nec-essary that ??????? also contains the upper side of the relation bracketed with another pair of brackets ?? = , . This is necessary for filtering out all the results without any brackets (see later filter ???? ?) and getting non optional replacement.  ??????? = ?? ? ?? ? ?????  ? In case of parallel replace rules, bracketed cen-ter is the union of all individual bracketed centers. Like XFST, this implementation requires parallel replace rules to have the same replace operator (and optionality) in all replacements. Step 2: The change centers in free context The second step is to expand bracketed center to be valid in any context. If ? = , , ,  ?, we can define: ? = ? ? ? ? ??????? ? Then, center in free context is: ??????? ? = ? ? ?  ????????  ?? where ? is diamond, which is used to align centers and contexts during compilation. Step 3: Expanded center in context The next step is to compile contexts. The method used for constructing ????????????  depends on whether the context must match on the upper or the lower side. Since it is possible to have multiple contexts, each replacement should be surrounded with all applicable contexts: ?????????? = ??| ??? ?|? | ??? Center surrounded with one context is: ?? = ? ?| ???  ??  ????????  ? ? ?| ??? , 
Remove brackets .r-glc. 
.r-glc. ? .r-glc. 
UBT 
Constraint 1 
Constraint N 
REPLACE RULE 
56
where ? and ? are left and right contexts from the replace rule, and ?? and ?? are expanded contexts, depending on which side the context matches. In the case when context must match on the upper side, ?? and ?? are: ?? = ? ?? ? B ?  ?. o. ? ?? ?? = ? ?? ? B  ?. o. ? ?? If they must match on the lower side: ?? = ?. o. ? ?? ? B  ? ?? = ?. o. ? ?? ? B  where brackets are freely inserted (?) in the con-texts and then composed with ?.  In this example:  ? ? ?  ?? ? ? ? ?_ ?? both contexts should match on the upper side of the replacement, so ??????????  is: ?? = ? ?c ? B ?  ?. o. ? ?? ?? = d ?? ? B  ?. o. ? ?? ?? = ( ?? ?| ???)  ? ??  ? ? ? ? ? ?  ?( ?? ?| ???) ?????????? = ?? This way of compiling contexts allows every rule in a parallel replace rule to have its own con-text direction (||, //, \\, \/). Therefore, rules like the following one are valid in this implementation:  ? ? ?  ?? ?\\ ?? ?_ ?? ?, , ? ? ?  ?? ?// ?? ?_ ?? Steps 4: Final operations Finally, to get the unconstrained replace transducer it is necessary to subtract ??????????  from ??????? ? , remove diamond and do a negation of that relation. Let ? = ? ? ? ? ??  ?? ??????? ?, then: ? ? ? ? ??  ???????? ?  ??  ???????????  ?  where ? ?? denotes removal of diamond. 3.2 Constraints All the preference constraints were defined in Yli-Jyr? (2008), but since they were mostly difficult to interpret and implement, here is the list of the con-straints written with regular expressions over the set of finite binary relations. First, let us define RP ? a regular expression of-ten used in the restraints: ?? =  ?  ?  ??: 0 ?  ?0:? ?  ???? ? ? The left most preference is achieved by: ?? = ? ???<: 0 ? ?: 0 ? ?  ???  ??? ? Right most preference: ?? =  ??? ? ??? ? ? ? ? ? 0 ??? ? ? Longest match left to right: 
?? =  ? ???  ?| ? 0:  ? 0:  ?  ?  ??0 ?  ?? ?] ??? ? ?? ??? = ???  ?  ? ? ? ?  ??? ? ? ? ?0 ?: ?  ? ???  ??? Longest match right to left: ?? =  ? ???  ?| ??? ? ? 0:  ? 0 ?  ?  ? ? ? 0  ?? ?] ????? =  ??? ???  ?0 ?  ? ? ?  ??? ? ? ?  ??? ? Shortest match left to right: ?? =  ? ???  ?| ?  ?0 ?  ?  ? ? ? 0 ?  ? ?0 ?  ?? ?] ??? ? ?? ???? = ???  ?  ? ? ? ?  ??? ? ? ? ? ? ? 0 ? ???  ??? Shortest match right to left: ?? =  ? ???  ?| ? ??? ? ?  ?0 ?  ?  ? ? ? 0 ?  ? ?0 ?  ?? ?] ?????? =  ??? ???  ?  ?: 0 ? ?  ??? ? ?  ? ? ??? For compiling epenthesis rules, to avoid more than one epsilon in the row: ?? =  ?,  ?  ?? =  ? ,  ?    ??  ? ?? ? = ???  ?????????  ???  For non-optional replacements: ???? ? = ???  ?[??: 0 ? ? ??? ? ???: 0 ??? ]? To remove paths containing ??, where ?? =  ? , : ?? ? ? = ??? ?? ??? Since ??  ? ?? ?  and ?? ? ?  are reflexive, they are not preference relation. Instead, they are filters applied after preference relations. 3.3 Applying constraints with .r-glc. operator To apply a preference constraint in order to restrict transducer t, we use .r-glc. operator. The .r-glc. operation between transducer t and a constraint is shown in Figure 2. Input language of a transducer is noted as proj1 and output language as proj2. 
 Figure 2: Breakdown of the operation: t .r-glc. constraint Contraints combinations As shown in Figure 1, in order to achieve desired replace rules, it is often necessary to use several constraints. For example, to achieve left to right longest match, it is necessary to combine ??  and 
.o. 
 
t 
proj1(t)   ? proj2 proj1(t) .o. constraint .o. proj1(t)  
57
?? ??? . If the same longest match contains epen-thesis, ??  ? ??  constraint should also be used. 3.4 Removing brackets Removing brackets is simply achieved by applying ?? ? = ??? ? ??? constraint, where B is set of brack-ets we want to remove. Additionally, in HFST implementation, it is also required to remove the brackets from the transducers alphabets.  4 Examples Let us show how the replace rule is compiled on different examples.  Since it would take too much space to show whole transducers, we will show only output of the intermediate results applied to an input string.  The first example shows how to achieve a non- optional replacement. Intermediate results of the replace rule ? ?  ?? ?|| ?? ?_ ?? is shown in the Table 2. Since the arrow demands non-optional replace-ment, the unconstrained bracketed replace, if ap-plied to the input string ? ?? ?? , contains three possible results. The first result is the input string itself, which would be part of the non-optional replacement. The second result is necessary to filter out the first one. In this example, because of the restricting context, replacement is possible only in the middle, and therefore, it is bracketed with special brackets. Finally, the third result contains the bracketed replace relation. ? ?  ?? ?|| ?? ?_ ?? UBT ???? ? ?? ? ? ? ?? ? ?? ? ? ?  ?? ? ?: ?  ?? ? ?: ?  ?? ? ? ?  ??  ? ?: ?  ??  Table 2: Steps of the non optional replacement  Once when we have the unconstrained bracket-ed replace transducer, we are ready to apply filters. First filter, ???? ? will filter out all results that contain smaller number of brackets in every posi-tion, without making difference to the type of brackets. In this example, it will filter out the first result, the one that does not have any brackets at all. The second filter, ?? ? ? will filter out all the results containing ??brackets because they don?t contain the replace relation. Finally, to get the final 
result, it is necessary to remove brackets from the relation.  Following examples will be shown on the input string ? ?? ?? ??. Table 3 shows steps of building left to right longest match and Table 4 left to right shortest match. Both longest match and shortest match have the same first two steps. After building Unconstrained Bracketed Replace, we apply ??  filter which finds all the results with left most brackets in every position and filters out all the rest. This contraints characteristic filters out the results without the brackets as well, so the result will be non-optional. In order to get the longest match, we apply another filter (?? ??? ) to the result of the left most filter. This filter finds the longest of the bracketed matches with the same starting position. In the final step, if we apply filter ?? ????  instead of ?? ??? , we will get the shortest match (Table 4). ?+ ?@? ?? ?|| ?? ?_ ?? UBT ??  ?? ???  ? ?? ?? ?? ? ?: ?  ?? ?? ? ?: ? ?: ?  ?? ? ?: ? ??: ?  ?? ? ?? ? ?: ?  ?? 
? ?: ?  ?? ?? ? ?: ? ?: ?  ?? ? ?: ? ??: ?  ??  
? ?: ? ??: ?  ??  
Table 3: Left to right longest match  ?+ ?@> ?? ?|| ?? ?_ ?? UBT ??  ?? ????  ? ?? ?? ?? ? ?: ?  ?? ?? ? ?: ? ?: ?  ?? ? ?: ? ??: ?  ?? ? ?? ? ?: ?  ?? 
? ?: ?  ?? ?? ? ?: ? ?: ?  ?? ? ?: ? ??: ?  ??  ? ?: ? ?: ?  ??  Table 4: Left to right shortest match 5 Conclusion The large number of different replace operators makes it quite complicated and error-prone to build a supporting framework for them. However, the .r-glc. operator and preference relations allow split-ting the algorithm into small reusable units which are easy to maintain and upgrade with new func-tionalities. The replace rules are now part of the HFST li-brary and can be used through hfst-regexp2fst command line tool, but there is still some work to 
58
be done to build an interactive interface. Addition-ally, we are planning to add support for two level contexts and parallel weighted rules.  Acknowledgments 
The research leading to these results has received funding from the European Commission?s 7th Framework Program under grant agreement n? 238405 (CLARA). References Beesley, K.R., Karttunen, L.: Finite State Morphology. CSLI publications (2003) Eisner, J.: Directional constraint evaluation in optimali-ty theory. In: 20th COLING 2000, Proceedings of the Conference, Saarbr?cken, Germany (2000) 257?263 Gerdemann, D. (2009). Mix and Match Replacement Rules. Proceedings of the Workshop on RANLP 2009 Workshop on Adaptation of Language Re-sources and Technology to New Domains, Borovets, Bulgaria, 2011, pages 39-47. Gerdemann, D., van Noord, G.: Approximation and exactness in Finite-State Optimality Theory. In Eis-ner, J., Karttunen, L., Th?riault, A., eds.: SIGPHON 2000, Finite State Phonology. (2000) Gerdemann, D., van Noord, G.: Transducers from re-write rules with backreferences. In: 9th EACL 1999, Proceedings of the Conference. (1999) 126?133 J?ger, G.: Gradient constraints in Finite State OT: The unidirectional and the bidirectional case. In: Proceed-ings of FSMNLP 2001, an ESSLLI Workshop, Hel-sinki (2001) (35?40) Karttunen, L.: The replace operator. In: 33th ACL 1995, Proceedings of the Conference, Cambridge, MA, USA (1995) 16?23 Karttunen, L.: Directed replace operator. In Roche, E., Schabes, Y., eds.: Finitestate language processing, Cambridge, Massachusetts, A Bradford Book. The MIT Press (1996) 117?147 Kempe, A., Karttunen, L.: Parallel replacement in finite state calculus. In: 16th COLING 1996, Proc. Conf. Volume 2., Copenhagen, Denmark (1996) 622?627 Lind?n, K., Axelson, E., Hardwick, S., Silfverberg, M., Pirinen, T.: HFST - Framework for Compiling and Applying Morphologies, Communications in Com-puter and Information Science, vol. 100, pp. 67-85. Springer Berlin Heidelberg (2011) Lind?n, K., Silfverberg, M., Pirinen, T.: Hfst tools for morphology - an efficient open-source package for construction of morphological analyzers. In: Mahlow, C., Pietrowski, M. (eds.) State of the Art in Computational Morphology. Communications in 
Computer and Information Science, vol. 41, pp. 28-47. Springer Berlin Heidelberg (2009) Yli-Jyr?, A., Koskenniemi, K.: A new method for com-piling parallel replacement rules. In Holub, J., ?d?rek, J., eds.: Implementation and Application of Automata, 12th International Conference, CIAA 2007, Revised Selected Papers. Volume 4783 of LNCS., Springer (2007) 320?321 Yli-Jyr?, A.: Applications of Diamonded Double Nega-tion. In Finite-state methods and natural language processing. Thomas Hanneforth and Kay-Michael W?rtzner. 6th International Workshop, FSMNLP 2007. Potsdam, Germany, September 14-16. Revised Papers. Universit?tsverlag Potsdam (2008a) 6-30 Yli-Jyr?, A., Transducers from Parallel Replace Rules and Modes with Generalized Lenient Composition. In Finite-state methods and natural language pro-cessing. Thomas Hanneforth and Kay-Michael W?rtzner. 6th International Workshop, FSMNLP 2007. Potsdam, Germany, September 14-16. Revised Papers. Universit?tsverlag Potsdam (2008b) 197-212 
59
