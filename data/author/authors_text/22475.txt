Proceedings of the 2013 Conference on Empirical Methods in Natural Language Processing, pages 1372?1376,
Seattle, Washington, USA, 18-21 October 2013. c?2013 Association for Computational Linguistics
Simple Customization of Recursive Neural Networks
for Semantic Relation Classification
Kazuma Hashimoto?, Makoto Miwa??, Yoshimasa Tsuruoka?, and Takashi Chikayama?
?The University of Tokyo, 3-7-1 Hongo, Bunkyo-ku, Tokyo, Japan
{hassy, tsuruoka, chikayama}@logos.t.u-tokyo.ac.jp
??The University of Manchester, 131 Princess Street, Manchester, M1 7DN, UK
makoto.miwa@manchester.ac.uk
Abstract
In this paper, we present a recursive neural
network (RNN) model that works on a syn-
tactic tree. Our model differs from previous
RNN models in that the model allows for an
explicit weighting of important phrases for the
target task. We also propose to average param-
eters in training. Our experimental results on
semantic relation classification show that both
phrase categories and task-specific weighting
significantly improve the prediction accuracy
of the model. We also show that averaging the
model parameters is effective in stabilizing the
learning and improves generalization capacity.
The proposed model marks scores competitive
with state-of-the-art RNN-based models.
1 Introduction
Recursive Neural Network (RNN) models are
promising deep learning models which have been
applied to a variety of natural language processing
(NLP) tasks, such as sentiment classification, com-
pound similarity, relation classification and syntactic
parsing (Hermann and Blunsom, 2013; Socher et al,
2012; Socher et al, 2013). RNN models can repre-
sent phrases of arbitrary length in a vector space of
a fixed dimension. Most of them use minimal syn-
tactic information (Socher et al, 2012).
Recently, Hermann and Blunsom (2013) pro-
posed a method for leveraging syntactic informa-
tion, namely CCG combinatory operators, to guide
composition of phrases in RNN models. While their
models were successfully applied to binary senti-
ment classification and compound similarity tasks,
there are questions yet to be answered, e.g., whether
such enhancement is beneficial in other NLP tasks
as well, and whether a similar improvement can
be achieved by using syntactic information of more
commonly available types such as phrase categories
and syntactic heads.
In this paper, we present a supervised RNN model
for a semantic relation classification task. Our model
is different from existing RNN models in that impor-
tant phrases can be explicitly weighted for the task.
Syntactic information used in our model includes
part-of-speech (POS) tags, phrase categories and
syntactic heads. POS tags are used to assign vec-
tor representations to word-POS pairs. Phrase cate-
gories are used to determine which weight matrices
are chosen to combine phrases. Syntactic heads are
used to determine which phrase is weighted during
combining phrases. To incorporate task-specific in-
formation, phrases on the path between entity pairs
are further weighted.
The second contribution of our work is the intro-
duction of parameter averaging into RNN models.
In our preliminary experiments, we observed that
the prediction performance of the model often fluc-
tuates significantly between training iterations. This
fluctuation not only leads to unstable performance
of the resulting models, but also makes it difficult to
fine-tune the hyperparameters of the model. Inspired
by Swersky et al (2010), we propose to average the
model parameters in the course of training. A re-
cent technique for deep learning models of similar
vein is dropout (Hinton et al, 2012), but averaging
is simpler to implement.
Our experimental results show that our model per-
1372
Figure 1: A recursive representations of a phrase ?a
word vector? with POS tags of the words (DT, NN and
NN respectively). For example, the two word-POS pairs
?word NN? and ?vector NN? with a syntactic category
N are combined to represent the phrase ?word vector?.
forms better than standard RNN models. By av-
eraging the model parameters, our model achieves
performance competitive with the MV-RNN model
in Socher et al (2012), without using computation-
ally expensive word-dependent matrices.
2 An Averaged RNN Model with Syntax
Our model is a supervised RNN that works on a bi-
nary syntactic tree. As our first step to leverage in-
formation available in the tree, we distinguish words
with the same spelling but POS tags in the vector
space. Our model also uses different weight ma-
trices dependent on the phrase categories of child
nodes (phrases or words) in combining phrases. Our
model further weights those nodes that appear to be
important.
Compositional functions of our model follow
those of the SU-RNN model in Socher et al (2013).
2.1 Word-POS Vector Representations
Our model simply assigns vector representations to
word-POS pairs. For example, a word ?caused?
can be represented in two ways: ?caused VBD? and
?caused VBN?. The vectors are represented as col-
umn vectors in a matrix We ? Rd?|V|, where d is
the dimension of a vector and V is a set of all word-
POS pairs we consider.
2.2 Compositional Functions with Syntax
In construction of parse trees, we associate each of
the tree node with its d-dimensional vector represen-
tation computed from vector representations of its
subtrees. For leaf nodes, we look up word-POS vec-
tor representations in V. Figure 1 shows an example
of such recursive representations. A parent vector
p ? Rd?1 is computed from its direct child vectors
cl and cr? Rd?1:
p = tanh(?lW
Tcl ,Tcr
l cl+?rW
Tcl ,Tcrr cr+bTcl ,Tcr ),
where W Tcl ,Tcrl and W
Tcl ,Tcrr ? Rd?d are weight
matrices that depend on the phrase categories of cl
and cr. Here, cl and cr have phrase categories Tcl
and Tcr respectively (such as N, V, etc.). bTcl ,Tcr ?
Rd?1 is a bias vector. To incorporate the impor-
tance of phrases into the model, two subtrees of a
node may have different weights ?l ? [0, 1] and
?r(= 1 ? ?l), taking phrase importance into ac-
count. The value of ?l is manually specified and
automatically applied to all nodes based on prior
knowledge about the task. In this way, we can com-
pute vector representations for phrases of arbitrary
length. We denote a set of such matrices as Wlr and
bias vectors as b.
2.3 Objective Function and Learning
As with other RNN models, we add on the top of a
node x a softmax classifier. The classifier is used to
predict a K-class distribution d(x) ? RK?1 over a
specific task to train our model:
d(x) = softmax(W labelx+ blabel), (1)
where W label ? RK?d is a weight matrix and
blabel ? RK?1 is a bias vector. We denote t(x) ?
RK?1 as the target distribution vector at node x.
t(x) has a 0-1 encoding: the entry at the correct la-
bel of t(x) is 1, and the remaining entries are 0. We
then compute the cross entropy error between d(x)
and t(x):
E(x) = ?
K
?
k=1
tk(x)logdk(x),
and define an objective function as the sum of E(x)
over all training data:
J(?) =
?
x
E(x) + ?
2
???2,
where ? = (We,Wlr, b,W label, blabel) is the set of
our model parameters that should be learned. ? is a
vector of regularization parameters.
1373
To compute d(x), we can directly leverage any
other nodes? feature vectors in the same tree. We
denote such additional feature vectors as x?i ? Rd?1,
and extend Eq. (1):
d(x) = softmax(W labelx+
?
i
W addi x?i +blabel),
where W addi ? RK?d are weight matrices for addi-
tional features. We denote these matrices W addi as
W add. We also add W add to ?:
? = (We,Wlr, b,W label,W add, blabel).
The gradient of J(?)
?J(?)
??
=
?
x
?E(x)
??
+ ??
is efficiently computed via backpropagation through
structure (Goller and Ku?chler, 1996). To minimize
J(?), we use batch L-BFGS1 (Hermann and Blun-
som, 2013; Socher et al, 2012).
2.4 Averaging
We use averaged model parameters
? = 1
T + 1
T
?
t=0
?t
at test time, where ?t is the vector of model parame-
ters after t iterations of the L-BFGS optimization.
Our preliminary experimental results suggest that
averaging ? except We works well.
3 Experimental Settings
We used the Enju parser (Miyao and Tsujii, 2008)
for syntactic parsing. We used 13 phrase categories
given by Enju.
3.1 Task: Semantic Relation Classification
We evaluated our model on a semantic relation clas-
sification task: SemEval 2010 Task 8 (Hendrickx et
al., 2010). Following Socher et al (2012), we re-
garded the task as a 19-class classification problem.
There are 8,000 samples for training, and 2,717 for
1We used libLBFGS provided at http://www.
chokkan.org/software/liblbfgs/.
Figure 2: Classifying the relation between two entities.
test. For the validation set, we randomly sampled
2,182 samples from the training data.
To predict a class label, we first find the minimal
phrase that covers the target entities and then use the
vector representation of the phrase (Figure 2).
As explained in Section 2.3, we can directly con-
nect features on any other nodes to the softmax clas-
sifier. In this work, we used three such internal fea-
tures: two vector representations of target entities
and one averaged vector representation of words be-
tween the entities2.
3.2 Weights on Phrases
We tuned the weight ?l (or ?r) introduced in Sec-
tion 2.2 for this particular task. There are two fac-
tors: syntactic heads and syntactic path between tar-
get entities. Our model puts a weight ? ? [0.5, 1]
on head phrases, and 1 ? ? on the others. For re-
lation classification tasks, syntactic paths between
target entities are important (Zhang et al, 2006), so
our model also puts another weight ? ? [0.5, 1] on
phrases on the path, and 1 ? ? on the others. When
both child nodes are on the path or neither of them
on the path, we set ? = 0.5. The two weight fac-
tors are summed up and divided by 2 to be the final
weights ?l and ?r to combine the phrases. For ex-
ample, we set ?l = (1??)+?2 and ?r =
?+(1??)
2
when the right child node is the head and the left
child node is on the path.
3.3 Initialization of Model Parameters and
Tuning of Hyperparameters
We initialized We with 50-dimensional word vec-
tors3 trained with the model of Collobert et
2Socher et al (2012) used richer features including words
around entity pairs in their implementation.
3The word vectors are provided at http://ronan.
collobert.com/senna/. We used the vectors without any
modifications such as normalization.
1374
Method F1 (%)
Our model 79.4
RNN 74.8
MV-RNN 79.1
RNN w/ POS, WordNet, NER 77.6
MV-RNN w/ POS, WordNet, NER 82.4
SVM w/ bag-of-words 73.1
SVM w/ lexical and semantic features 82.2
Table 1: Comparison of our model with other methods on
SemEval 2010 task 8.
Method F1 (%)
Our model 79.4
Our model w/o phrase categories (PC) 77.7
Our model w/o head weights (HW) 78.8
Our model w/o path weights (PW) 78.7
Our model w/o averaging (AVE) 76.9
Our model w/o PC, HW, PW, AVE 74.1
Table 2: Contributions of syntactic and task-specific in-
formation and averaging.
al. (2011), and Wlr with I2 + ?, where I ? Rd?d
is an identity matrix. Here, ? is zero-mean gaussian
random variable with a variance of 0.01. The ini-
tialization of Wlr is the same as that of Socher et
al. (2013). The remaining model parameters were
initialized with 0.
We tuned hyperparameters in our model using the
validation set for each experimental setting. The hy-
perparameters include the regularization parameters
for We, Wlr, W label and W add, and the weights ?
and ?. For example, the best performance for our
model with all the proposed methods was obtained
with the values: 10?6, 10?4, 10?3, 10?3, 0.7 and
0.9 respectively.
4 Results and Discussion
Table 1 shows the performance of our model and that
of previously reported systems on the test set. The
performance of an SVM system with bag-of-words
features was reported in Rink and Harabagiu (2010),
and the performance of the RNN and MV-RNN
models was reported in Socher et al (2012). Our
model achieves an F1 score of 79.4% and outper-
forms the RNN model (74.8% F1) as well as the
simple SVM-based system (73.1% F1). More no-
Figure 3: F1 vs Training iterations.
tably, the score of our model is competitive with that
of the MV-RNN model (79.1% F1), which is com-
putationally much more expensive. Readers are re-
ferred to Hermann and Blunsom (2013) for the dis-
cussion about the computational complexity of the
MV-RNN model. We improved the performance of
RNN models on the task without much increasing
the complexity. This is a significant practical advan-
tage of our model, although its expressive power is
not the same as that of the MV-RNN model.
Our model outperforms the RNN model with one
lexical and two semantic external features: POS
tags, WordNet hypernyms and named entity tags
(NER) of target word pairs (external features). The
MV-RNN model with external features shows bet-
ter performance than our model. An SVM with rich
lexical and semantic features (Rink and Harabagiu,
2010) also outperforms ours. Note, however, that
this is not a fair comparison because those mod-
els use rich external resources such as WordNet and
named entity tags.
4.1 Contributions of Proposed Methods
We conducted additional experiments to quantify the
contributions of phrase categories, heads, paths and
averaging to our classification score. As shown in
Table 2, our model without phrase categories, heads
or paths still outperforms the RNN model with ex-
ternal features. On the other hand, our model with-
out averaging yields a lower score than the RNN
model with external features, though it is still bet-
1375
ter than the RNN model alone. Without utiliz-
ing these four properties, our model obtained only
74.1% F1. These results indicate that syntactic and
task-specific information and averaging contribute
to the performance improvement. The improvement
is achieved by a simple modification of composi-
tional functions in RNN models.
4.2 Effects of Averaging in Training
Figure 3 shows the training curves in terms of F1
scores. These curves clearly demonstrate that pa-
rameter averaging helps to stabilize the learning and
improve generalization capacity.
5 Conclusion
We have presented an averaged RNN model for se-
mantic relation classification. Our experimental re-
sults show that syntactic information such as phrase
categories and heads improves the performance, and
the task-specific weighting is also beneficial. The
results also demonstrate that averaging the model
parameters not only stabilizes the learning but also
improves the generalization capacity of the model.
As future work, we plan to combine deep learning
models with richer information such as predicate-
argument structures.
Acknowledgments
We thank the anonymous reviewers for their insight-
ful comments.
References
Ronan Collobert, Jason Weston, Le?on Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa. 2011.
Natural Language Processing (almost) from Scratch.
In JMLR, 12:2493?2537.
Christoph Goller and Andreas Ku?chler. 1996. Learning
Task-Dependent Distributed Representations by Back-
propagation Through Structure. In ICNN.
Iris Hendrickx, Su Nam Kim, Zornitsa Kozareva, Preslav
Nakov, Diarmuid ?O Se?aghdha, Sebastian Pado?, Marco
Pennacchiotti, Lorenza Romano and Stan Szpakowicz.
2010. SemEval-2010 Task 8: Multi-Way Classication
of Semantic Relations Between Pairs of Nominals. In
SemEval 2010.
Karl Moritz Hermann and Phil Blunsom. 2013. The Role
of Syntax in Vector Space Models of Compositional Se-
mantics. In ACL.
Geoffrey E. Hinton, Nitish Srivastava, Alex Krizhevsky,
Ilya Sutskever and Ruslan R. Salakhutdinov. 2012.
Improving neural networks by preventing co-
adaptation of feature detectors. In arXiv:1207.0580.
Yusuke Miyao and Jun?ichi Tsujii. 2008. Feature Forest
Models for Probabilistic HPSG Parsing. In Computa-
tional Linguistics, 34(1):35?80, MIT Press.
Bryan Rink and Sanda Harabagiu. 2010. UTD: Clas-
sifying Semantic Relations by Combining Lexical and
Semantic Resources. In SemEval 2010.
Richard Socher, Brody Huval, Christopher D. Manning
and Andrew Y. Ng. 2012. Semantic Compositionality
Through Recursive Matrix-Vector Spaces. In EMNLP.
Richard Socher, John Bauer, Christopher D. Manning and
Andrew Y. Ng. 2013. Parsing with Compositional
Vector Grammars. In ACL.
Kevin Swersky, Bo Chen, Ben Marlin and Nando de Fre-
itas. 2010. A tutorial on stochastic approximation al-
gorithms for training Restricted Boltzmann Machines
and Deep Belief Nets. In ITA workshop.
Min Zhang, Jie Zhang, Jian Su and Guodong Zhou. 2006.
A Composite Kernel to Extract Relations between En-
tities with Both Flat and Structured Features. In COL-
ING/ACL.
1376
Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP), pages 1544?1555,
October 25-29, 2014, Doha, Qatar. c?2014 Association for Computational Linguistics
Jointly Learning Word Representations and Composition Functions
Using Predicate-Argument Structures
Kazuma Hashimoto?, Pontus Stenetorp?, Makoto Miwa?, and Yoshimasa Tsuruoka?
?The University of Tokyo, 3-7-1 Hongo, Bunkyo-ku, Tokyo, Japan
{hassy,pontus,tsuruoka}@logos.t.u-tokyo.ac.jp
?Toyota Technological Institute, 2-12-1 Hisakata, Tempaku-ku, Nagoya, Japan
makoto-miwa@toyota-ti.ac.jp
Abstract
We introduce a novel compositional lan-
guage model that works on Predicate-
Argument Structures (PASs). Our model
jointly learns word representations and
their composition functions using bag-
of-words and dependency-based con-
texts. Unlike previous word-sequence-
based models, our PAS-based model com-
poses arguments into predicates by using
the category information from the PAS.
This enables our model to capture long-
range dependencies between words and
to better handle constructs such as verb-
object and subject-verb-object relations.
We verify this experimentally using two
phrase similarity datasets and achieve re-
sults comparable to or higher than the pre-
vious best results. Our system achieves
these results without the need for pre-
trained word vectors and using a much
smaller training corpus; despite this, for
the subject-verb-object dataset our model
improves upon the state of the art by as
much as ?10% in relative performance.
1 Introduction
Studies on embedding single words in a vector
space have made notable successes in capturing
their syntactic and semantic properties (Turney
and Pantel, 2010). These embeddings have also
been found to be a useful component for Natural
Language Processing (NLP) systems; for exam-
ple, Turian et al. (2010) and Collobert et al. (2011)
demonstrated how low-dimensional word vectors
learned by Neural Network Language Models
(NNLMs) are beneficial for a wide range of NLP
tasks.
Recently, the main focus of research on vector
space representation is shifting from word repre-
sentations to phrase representations (Baroni and
Zamparelli, 2010; Grefenstette and Sadrzadeh,
2011; Mitchell and Lapata, 2010; Socher et al.,
2012). Combining the ideas of NNLMs and se-
mantic composition, Tsubaki et al. (2013) intro-
duced a novel NNLM incorporating verb-object
dependencies. More recently, Levy and Goldberg
(2014) presented a NNLM that integrated syntac-
tic dependencies. However, to the best of our
knowledge, there is no previous work on integrat-
ing a variety of syntactic and semantic dependen-
cies into NNLMs in order to learn composition
functions as well as word representations. The fol-
lowing question thus arises naturally:
Can a variety of dependencies be used to
jointly learn both stand-alone word vectors
and their compositions, embedding them in
the same vector space?
In this work, we bridge the gap between
purely context-based (Levy and Goldberg, 2014;
Mikolov et al., 2013b; Mnih and Kavukcuoglu,
2013) and compositional (Tsubaki et al., 2013)
NNLMs by using the flexible set of categories
from Predicate-Argument-Structures (PASs).
More specifically, we propose a Compositional
Log-Bilinear Language Model using PASs (PAS-
CLBLM), an overview of which is shown in
Figure 1. The model is trained by maximizing
the accuracy of predicting target words from their
bag-of-words and dependency-based context,
which provides information about selectional
preference. As shown in Figure 1 (b), one of the
advantages of the PAS-CLBLM is that the model
can treat not only word vectors but also composed
vectors as contexts. Since the composed vectors
1544
Figure 1: An overview of the proposed model: PAS-CLBLM. (a) The PAS-LBLM predicts target words
from their bag-of-words and dependency-based context words. (b) The PAS-CLBLM predicts target
words using not only context words but also composed vector representations derived from another level
of predicate-argument structures. Underlined words are target words and we only depict the bag-of-
words vector for the PAS-CLBLM.
are treated as input to the language model in
the same way as word vectors, these composed
vectors are expected to become similar to word
vectors for words with similar meanings.
Our empirical results demonstrate that the pro-
posed model has the ability to learn meaning-
ful representations for adjective-noun, noun-noun,
and (subject-) verb-object dependencies. On three
tasks of measuring the semantic similarity be-
tween short phrases (adjective-noun, noun-noun,
and verb-object), the learned composed vectors
achieve scores (Spearman?s rank correlation ?)
comparable to or higher than those of previ-
ous models. On a task involving more complex
phrases (subject-verb-object), our learned com-
posed vectors achieve state-of-the-art performance
(? = 0.50) with a training corpus that is an order
of magnitude smaller than that used by previous
work (Tsubaki et al., 2013; Van de Cruys et al.,
2013). Moreover, the proposed model does not
require any pre-trained word vectors produced by
external models, but rather induces word vectors
jointly while training.
2 Related Work
There is a large body of work on how to represent
the meaning of a word in a vector space. Distri-
butional approaches assume that the meaning of
a word is determined by the contexts in which it
appears (Firth, 1957). The context of a word is of-
ten defined as the words appearing in a window
of fixed-length (bag-of-words) and a simple ap-
proach is to treat the co-occurrence statistics of a
word w as a vector representation for w (Mitchell
and Lapata, 2008; Mitchell and Lapata, 2010); al-
ternatively, dependencies between words can be
used to define contexts (Goyal et al., 2013; Erk
and Pado?, 2008; Thater et al., 2010).
In contrast to distributional representations,
NNLMs represent words in a low-dimensional
vector space (Bengio et al., 2003; Collobert et al.,
2011). Recently, Mikolov et al. (2013b) and Mnih
and Kavukcuoglu (2013) proposed highly scalable
models to learn high-dimensional word vectors.
Levy and Goldberg (2014) extended the model of
Mikolov et al. (2013b) by treating syntactic depen-
dencies as contexts.
Mitchell and Lapata (2008) investigated a vari-
ety of compositional operators to combine word
vectors into phrasal representations. Among these
operators, simple element-wise addition and mul-
tiplication are now widely used to represent short
phrases (Mitchell and Lapata, 2010; Blacoe and
Lapata, 2012). The obvious limitation with these
simple approaches is that information about word
order and syntactic relations is lost.
To incorporate syntactic information into com-
position functions, a variety of compositional
models have been proposed. These include recur-
sive neural networks using phrase-structure trees
(Socher et al., 2012; Socher et al., 2013b) and
models in which words have a specific form of
parameters according to their syntactic roles and
composition functions are syntactically dependent
on the relations of input words (Baroni and Zam-
parelli, 2010; Grefenstette and Sadrzadeh, 2011;
Hashimoto et al., 2013; Hermann and Blunsom,
2013; Socher et al., 2013a).
More recently, syntactic dependency-based
1545
compositional models have been proposed (Pa-
perno et al., 2014; Socher et al., 2014; Tsub-
aki et al., 2013). One of the advantages of these
models is that they are less restricted by word or-
der. Among these, Tsubaki et al. (2013) intro-
duced a novel compositional NNLM mainly fo-
cusing on verb-object dependencies and achieved
state-of-the-art performance for the task of mea-
suring the semantic similarity between subject-
verb-object phrases.
3 PAS-CLBLM: A Compositional
Log-Bilinear Language Model Using
Predicate-Argument Structures
In some recent studies on representing words as
vectors, word vectors are learned by solving word
prediction tasks (Mikolov et al., 2013a; Mnih and
Kavukcuoglu, 2013). More specifically, given tar-
get words and their context words, the basic idea
is to train classifiers to discriminate between each
target word and artificially induced negative tar-
get words. The feature vector of the classifiers are
calculated using the context word vectors whose
values are optimized during training. As a result,
vectors of words in similar contexts become simi-
lar to each other.
Following these studies, we propose a novel
model to jointly learn representations for words
and their compositions by training word predic-
tion classifiers using PASs. In this section, we
first describe the predicate-argument structures as
they serve as the basis of our model. We then
introduce a Log-Bilinear Language Model us-
ing Predicate-Argument Structures (PAS-LBLM)
to learn word representations using both bag-of-
words and dependency-based contexts. Finally,
we propose integrating compositions of words into
the model. Figure 1 (b) shows the overview of the
proposed model.
3.1 Predicate-Argument Structures
Due to advances in deep parsing technologies,
syntactic parsers that can produce predicate-
argument structures are becoming accurate and
fast enough to be used for practical applications.
In this work, we use the probabilistic HPSG
parser Enju (Miyao and Tsujii, 2008) to obtain the
predicate-argument structures of individual sen-
tences. In its grammar, each word in a sentence
is treated as a predicate of a certain category with
zero or more arguments. Table 1 shows some ex-
Category predicate arg1 arg2
adj arg1 heavy rain
noun arg1 car accident
verb arg12 cause rain accident
prep arg12 at eat restaurant
Table 1: Examples of predicates of different cate-
gories from the grammar of the Enju parser. arg1
and arg2 denote the first and second arguments.
amples of predicates of different categories.1 For
example, a predicate of the category verb arg12
expresses a verb with two arguments. A graph can
be constructed by connecting words in predicate-
argument structures in a sentence; in general, these
graphs are acyclic.
One of the merits of using predicate-argument
structures is that they can capture dependencies
between more than two words, while standard syn-
tactic dependency structures are limited to depen-
dencies between two words. For example, one of
the predicates in the phrase ?heavy rain caused car
accidents? is the verb ?cause?, and it has two ar-
guments (?rain? and ?accident?). Furthermore, ex-
actly the same predicate-argument structure (pred-
icate: cause, first argument: rain, second argu-
ment: accident) is extracted from the passive form
of the above phrase: ?car accidents were caused
by heavy rain?. This is helpful when capturing
semantic dependencies between predicates and ar-
guments, and in extracting facts or relations de-
scribed in a sentence, such as who did what to
whom.
3.2 A Log-Bilinear Language Model Using
Predicate-Argument Structures
3.2.1 PAS-based Word Prediction
The PAS-LBLM predicts a target word given its
PAS-based context. We assume that each word
w in the vocabulary V is represented with a d-
dimensional vector v(w). When a predicate of
category c is extracted from a sentence, the PAS-
LBLM computes the predicted d-dimensional vec-
tor p(w
t
) for the target word w
t
from its context
words w
1
, w
2
, . . . , w
m
:
p(w
t
) = f
(
m
?
i=1
h
c
i
? v(w
i
)
)
, (1)
1The categories of the predicates in the Enju parser are
summarized at http://kmcs.nii.ac.jp/
?
yusuke/
enju/enju-manual/enju-output-spec.html.
1546
where hc
i
? R
d?1 are category-specific weight
vectors and ? denotes element-wise multiplica-
tion. f is a non-linearity function; in this work
we define f as tanh.
As an example following Figure 1 (a), when
the predicate ?cause? is extracted with its first
and second arguments ?rain? and ?accident?, the
PAS-LBLM computes p(cause) ? Rd following
Eq. (1):
p(cause) = f(h
verb arg12
arg1
? v(rain)+
h
verb arg12
arg2
? v(accident)).
(2)
In Eq. (2), the predicate is treated as the target
word, and its arguments are treated as the con-
text words. In the same way, an argument can be
treated as a target word:
p(rain) = f(h
verb arg12
verb
? v(cause)+
h
verb arg12
arg2
? v(accident)).
(3)
Relationship to previous work. If we omit the
the category-specific weight vectors hc
i
in Eq. (1),
our model is similar to the CBOW model in
Mikolov et al. (2013a). CBOW predicts a tar-
get word given its surrounding bag-of-words con-
text, while our model uses its PAS-based context.
To incorporate the PAS information in our model
more efficiently, we use category-specific weight
vectors. Similarly, the vLBL model of Mnih and
Kavukcuoglu (2013) uses different weight vec-
tors depending on the position relative to the tar-
get word. As with previous neural network lan-
guage models (Collobert et al., 2011; Huang et al.,
2012), our model and vLBL can use weight ma-
trices rather than weight vectors. However, as dis-
cussed by Mnih and Teh (2012), using weight vec-
tors makes the training significantly faster than us-
ing weight matrices. Despite the simple formula-
tion of the element-wise operations, the category-
specific weight vectors efficiently propagate PAS-
based context information as explained next.
3.2.2 Training Word Vectors
To train the PAS-LBLM, we use a scoring function
to evaluate how well the target word w
t
fits the
given context:
s(w
t
, p(w
t
)) = v?(w
t
)
T
p(w
t
), (4)
where v?(w
t
) ? R
d?1 is the scoring weight vector
for w
t
. Thus, the model parameters in the PAS-
LBLM are (V, ?V ,H). V is the set of word vec-
tors v(w), and ?V is the set of scoring weight vec-
tors v?(w). H is the set of the predicate-category-
specific weight vectors hc
i
.
Based on the objective in the model of Collobert
et al. (2011), the model parameters are learned by
minimizing the following hinge loss:
N
?
n=1
max(1? s(w
t
, p(w
t
)) + s(w
n
, p(w
t
)), 0),
(5)
where the negative sample w
n
is a randomly sam-
pled word other than w
t
, and N is the number
of negative samples. In our experiments we set
N = 1. Following Mikolov et al. (2013b), nega-
tive samples were drawn from the distribution over
unigrams that we raise to the power 0.75 and then
normalize to once again attain a probability distri-
bution. We minimize the loss function in Eq. (5)
using AdaGrad (Duchi et al., 2011). For further
training details, see Section 4.5.
Relationship to softmax regression models.
The model parameters can be learned by maximiz-
ing the log probability of the target word w
t
based
on the softmax function:
p(w
t
|context) =
exp(s(w
t
, p(w
t
)))
?
|V|
i=1
exp(s(w
i
, p(w
t
)))
. (6)
This is equivalent to a softmax regression model.
However, when the vocabulary V is large, com-
puting the softmax function in Eq. (6) is compu-
tationally expensive. If we do not need probabil-
ity distributions over words, we are not necessar-
ily restricted to using the probabilistic expressions.
Recently, several methods have been proposed to
efficiently learn word representations rather than
accurate language models (Collobert et al., 2011;
Mikolov et al., 2013b; Mnih and Kavukcuoglu,
2013), and our objective follows the work of Col-
lobert et al. (2011). Mikolov et al. (2013b) and
Mnih and Kavukcuoglu (2013) trained their mod-
els using word-dependent scoring weight vectors
which are the arguments of our scoring function
in Eq. (4). During development we also trained
our model using the negative sampling technique
of Mikolov et al. (2013b); however, we did not ob-
serve any significant performance difference.
Intuition behind the PAS-LBLM. Here we
briefly explain how each class of the model pa-
rameters of the PAS-LBLM contributes to learning
word representations at each stochastic gradient
1547
decent step. The category-specific weight vectors
provide the PAS information for context word vec-
tors which we would like to learn. During train-
ing, context word vectors having the same PAS-
based syntactic roles are updated similarly. The
word-dependent scoring weight vectors propagate
the information on which words should, or should
not, be predicted. In effect, context word vectors
making similar contributions to word predictions
are updated similarly. The non-linear function f
provides context words with information on the
other context words in the same PAS. In this way,
word vectors are expected to be learned efficiently
by the PAS-LBLM.
3.3 Learning Composition Functions
As explained in Section 3.1, predicate-argument
structures inherently form graphs whose nodes are
words in a sentence. Using the graphs, we can in-
tegrate relationships between multiple predicate-
argument structures into our model.
When the context word w
i
in Eq. (1), excluding
predicate words, has another predicate-argument
of category c? as a dependency, we replace v(w
i
)
with the vector produced by the composition func-
tion for the predicate category c?. For example,
as shown in Figure 1 (b), when the first argument
?rain? of the predicate ?cause? is also the argu-
ment of the predicate ?heavy?, we first compute
the d-dimensional composed vector representation
for ?heavy? and ?rain?:
g
c
?
(v(heavy), v(rain)), (7)
where c? is the category adj arg1, and g
c
? is a func-
tion to combine input vectors for the predicate-
category c?. We can use any composition func-
tion that produces a representation of the same
dimensionality as its inputs, such as element-
wise addition/multiplication (Mitchell and Lap-
ata, 2008) or neural networks (Socher et al.,
2012). We then replace v(rain) in Eq. (2) with
g
c
?
(v(heavy), v(rain)). When the second argu-
ment ?accident? in Eq. (2) is also the argument
of the predicate ?car?, v(accident) is replaced
with g
c
??
(v(car), v(accident)). c
?? is the predi-
cate category noun arg1. These multiple relation-
ships of predicate-argument structures should pro-
vide richer context information. We refer to the
PAS-LBLM with composition functions as PAS-
CLBLM.
3.4 Bag-of-Words Sensitive PAS-CLBLM
Both the PAS-LBLM and PAS-CLBLM can take
meaningful relationships between words into ac-
count. However, at times, the number of context
words can be limited and the ability of other mod-
els to take ten or more words from a fixed con-
text in a bag-of-words (BoW) fashion could com-
pensate for this sparseness. Huang et al. (2012)
combined local and global contexts in their neural
network language models, and motivated by their
work, we integrate bag-of-words vectors into our
models. Concretely, we add an additional input
term to Eq. (1):
p(w
t
) = f
(
m
?
i=1
h
c
i
? v(w
i
) + h
c
BoW
? v(BoW)
)
,
(8)
where hc
BoW
? R
d?1 are additional weight vec-
tors, and v(BoW) ? Rd?1 is the average of the
word vectors in the same sentence. To construct
the v(BoW) for each sentence, we average the
word vectors of nouns and verbs in the same sen-
tence, excluding the target and context words.
4 Experimental Settings
4.1 Training Corpus
We used the British National Corpus (BNC) as our
training corpus, extracted 6 million sentences from
the original BNC files, and parsed them using the
Enju parser described in Section 3.1.
4.2 Word Sense Disambiguation Using
Part-of-Speech Tags
In general, words can have multiple syntactic us-
ages. For example, the word cause can be a
noun or a verb depending on its context. Most
of the previous work on learning word vectors
ignores this ambiguity since word sense disam-
biguation could potentially be performed after the
word vectors have been trained (Huang et al.,
2012; Kartsaklis and Sadrzadeh, 2013). Some re-
cent work explicitly assigns an independent vec-
tor for each word usage according to its part-of-
speech (POS) tag (Hashimoto et al., 2013; Kart-
saklis and Sadrzadeh, 2013). Alternatively, Baroni
and Zamparelli (2010) assigned different forms of
parameters to adjectives and nouns.
In our experiments, we combined each word
with its corresponding POS tags. We used the
base-forms provided by the Enju parser rather than
1548
Figure 2: Two PAS-CLBLM training samples.
the surface-forms, and used the first two charac-
ters of the POS tags. For example, VB, VBP,
VBZ, VBG, VBD, VBN were all mapped to VB.
This resulted in two kinds of cause: cause NN and
cause VB and we used the 100,000 most frequent
lowercased word-POS pairs in the BNC.
4.3 Selection of Training Samples Based on
Categories of Predicates
To train the PAS-LBLM and PAS-CLBLM, we
could use all predicate categories. However, our
preliminary experiments showed that these cate-
gories covered many training samples which are
not directly relevant to our experimental setting,
such as determiner-noun dependencies. We thus
manually selected the categories used in our ex-
periments. The selected predicates are listed in
Table 1: adj arg1, noun arg1, prep arg12, and
verb arg12. These categories should provide
meaningful information on selectional preference.
For example, the prep arg12 denotes prepositions
with two arguments, such as ?eat at restaurant?
which means that the verb ?eat? is related to the
noun ?restaurant? by the preposition ?at?. Prepo-
sitions are one of the predicates whose arguments
can be verbs, and thus prepositions are important
in training the composition functions for (subject-)
verb-object dependencies as described in the next
paragraph.
Another point we had to consider was how
to construct the training samples for the PAS-
CLBLM. We constructed compositional training
samples as explained in Section 3.3 when c? was
adj arg1, noun arg1, or verb arg12. Figure 2
shows two examples in addition to the example
in Figure 1 (b). Using such training samples, the
PAS-CLBLM could, for example, recognize from
the two predicate-argument structures, ?eat food?
and ?eat at restaurant?, that eating foods is an ac-
tion that occurs at restaurants.
Model Composition Function
Add
l
v(w
1
) + v(w
2
)
Add
nl
tanh(v(w
1
) + v(w
2
))
Wadd
l
m
c
adj
? v(w
1
) + m
c
arg1
? v(w
2
)
Wadd
nl
tanh(m
c
adj
?v(w
1
)+m
c
arg1
?v(w
2
))
Table 2: Composition functions used in this work.
The examples are shown as the adjective-noun de-
pendency between w
1
=?heavy? and w
2
=?rain?.
4.4 Selection of Composition Functions
As described in Section 3.3, we are free to se-
lect any composition functions in Eq. (7). To
maintain the fast training speed of the PAS-
LBLM, we avoid dense matrix-vector multiplica-
tion in our composition functions. In Table 2,
we list the composition functions used for the
PAS-CLBLM. Add
l
is element-wise addition and
Add
nl
is element-wise addition with the non-
linear function tanh. The subscripts l and nl de-
note the words linear and non-linear. Similarly,
Wadd
l
is element-wise weighted addition and
Wadd
nl
is element-wise weighted addition with
the non-linear function tanh. The weight vec-
tors mc
i
? R
d?1 in Table 2 are predicate-category-
specific parameters which are learned during train-
ing. We investigate the effects of the non-linear
function tanh for these composition functions.
In the formulations of the backpropagation algo-
rithm, non-linear functions allow the input vectors
to weakly interact with each other.
4.5 Initialization and Optimization of Model
Parameters
We assigned a 50-dimensional vector for each
word-POS pair described in Section 4.2 and ini-
tialized the vectors and the scoring weight vec-
tors using small random values. In part inspired
by the initialization method of the weight matrices
in Socher et al. (2013a), we initialized all values
in the compositional weight vectors of the Wadd
l
and Wadd
nl
as 1.0. The context weight vectors
were initialized using small random values.
We minimized the loss function in Eq. (5) us-
ing mini-batch SGD and AdaGrad (Duchi et al.,
2011). Using AdaGrad, the SGD?s learning rate
is adapted independently for each model parame-
ter. This is helpful in training the PAS-LBLM and
PAS-CLBLM, as they have conditionally depen-
dent model parameters with varying frequencies.
1549
The mini-batch size was 32 and the learning rate
was 0.05 for each experiment, and no regulariza-
tion was used. To verify the semantics captured by
the proposed models during training and to tune
the hyperparameters, we used the WordSim-3532
word similarity data set (Finkelstein et al., 2001).
5 Evaluation on Phrase Similarity Tasks
5.1 Evaluation Settings
The learned models were evaluated on four tasks
of measuring the semantic similarity between
short phrases. We performed evaluation using the
three tasks (AN, NN, and VO) in the dataset3 pro-
vided by Mitchell and Lapata (2010), and the SVO
task in the dataset4 provided by Grefenstette and
Sadrzadeh (2011).
The datasets include pairs of short phrases ex-
tracted from the BNC. AN, NN, and VO con-
tain 108 phrase pairs of adjective-noun, noun-
noun, and verb-object. SVO contains 200 pairs of
subject-verb-object phrases. Each phrase pair has
multiple human-ratings: the higher the rating is,
the more semantically similar the phrases. For ex-
ample, the subject-verb-object phrase pair of ?stu-
dent write name? and ?student spell name? has a
high rating. The pair ?people try door? and ?peo-
ple judge door? has a low rating.
For evaluation we used the Spearman?s rank
correlation ? between the human-ratings and the
cosine similarity between the composed vector
pairs. We mainly used non-averaged human-
ratings for each pair, and as described in Section
5.3, we also used averaged human-ratings for the
SVO task. Each phrase pair in the datasets was an-
notated by more than two annotators. In the case
of averaged human ratings, we averaged multiple
human-ratings for each phrase pair, and in the case
of non-averaged human-ratings, we treated each
human-rating as a separate annotation.
With the PAS-CLBLM, we represented each
phrase using the composition functions listed in
Table 2. When there was no composition present,
we represented the phrase using element-wise ad-
dition. For example, when we trained the PAS-
CLBLM with the composition function Wadd
nl
,
2http://www.cs.technion.ac.il/
?
gabr/
resources/data/wordsim353/
3http://homepages.inf.ed.ac.uk/
s0453356/share
4http://www.cs.ox.ac.uk/activities/
compdistmeaning/GS2011data.txt
Model AN NN VO
PAS-CLBLM (Add
l
) 0.52 0.44 0.35
PAS-CLBLM (Add
nl
) 0.52 0.46 0.45
PAS-CLBLM (Wadd
l
) 0.48 0.39 0.34
PAS-CLBLM (Wadd
nl
) 0.48 0.40 0.39
PAS-LBLM 0.41 0.44 0.39
word2vec 0.52 0.48 0.42
BL w/ BNC 0.48 0.50 0.35
HB w/ BNC 0.41 0.44 0.34
KS w/ ukWaC n/a n/a 0.45
K w/ BNC n/a n/a 0.41
Human agreement 0.52 0.49 0.55
Table 3: Spearman?s rank correlation scores ? for
the three tasks: AN, NN, and VO.
the composed vector for each phrase was com-
puted using the Wadd
nl
function, and when we
trained the PAS-LBLM, we used the element-wise
addition function. To compute the composed vec-
tors using the Wadd
l
and Wadd
nl
functions, we
used the categories of the predicates adj arg1,
noun arg1, and verb arg12 listed in Table 1.
As a strong baseline, we trained the Skip-gram
model of Mikolov et al. (2013b) using the pub-
licly available word2vec5 software. We fed the
POS-tagged BNC into word2vec since our models
utilize POS tags and trained 50-dimensional word
vectors using word2vec. For each phrase we then
computed the representation using vector addition.
5.2 AN, NN, and VO Tasks
Table 3 shows the correlation scores ? for the AN,
NN, and VO tasks. Human agreement denotes the
inter-annotator agreement. The word2vec baseline
achieves unexpectedly high scores for these three
tasks. Previously these kinds of models (Mikolov
et al., 2013b; Mnih and Kavukcuoglu, 2013) have
mainly been evaluated for word analogy tasks and,
to date, there has been no work using these word
vectors for the task of measuring the semantic sim-
ilarity between phrases. However, this experimen-
tal result suggests that word2vec can serve as a
strong baseline for these kinds of tasks, in addi-
tion to word analogy tasks.
In Table 3, BL, HB, KS, and K denote the work
of Blacoe and Lapata (2012), Hermann and Blun-
som (2013), Kartsaklis and Sadrzadeh (2013), and
Kartsaklis et al. (2013) respectively. Among these,
5https://code.google.com/p/word2vec/
1550
Averaged Non-averaged
Model Corpus SVO-SVO SVO-V SVO-SVO SVO-V
PAS-CLBLM (Add
l
) 0.29 0.34 0.24 0.28
PAS-CLBLM (Add
nl
) 0.27 0.32 0.24 0.28
PAS-CLBLM (Wadd
l
) BNC 0.25 0.26 0.21 0.23
PAS-CLBLM (Wadd
nl
) 0.42 0.50 0.34 0.41
PAS-LBLM 0.21 0.06 0.18 0.08
word2vec BNC 0.12 0.32 0.12 0.28
Grefenstette and Sadrzadeh (2011) BNC n/a n/a 0.21 n/a
Tsubaki et al. (2013) ukWaC n/a 0.47 n/a n/a
Van de Cruys et al. (2013) ukWaC n/a n/a 0.32 0.37
Human agreement 0.75 0.62
Table 4: Spearman?s rank correlation scores ? for the SVO task. Averaged denotes the ? calculated by
averaged human ratings, and Non-averaged denotes the ? calculated by non-averaged human ratings.
only Kartsaklis and Sadrzadeh (2013) used the
ukWaC corpus (Baroni et al., 2009) which is an or-
der of magnitude larger than the BNC. As we can
see in Table 3, the PAS-CLBLM (Add
nl
) achieves
scores comparable to and higher than those of the
baseline and the previous state-of-the-art results.
In relation to these results, the Wadd
l
and Wadd
nl
variants of the PAS-CLBLM do not achieve great
improvements in performance. This indicates that
simple word vector addition can be sufficient to
compose representations for phrases consisting of
word pairs.
5.3 SVO Task
Table 4 shows the correlation scores ? for the SVO
task. The scores ? for this task are reported for
both averaged and non-averaged human ratings.
This is due to a disagreement in previous work
regarding which metric to use when reporting re-
sults. Hence, we report the scores for both settings
in Table 4. Another point we should consider is
that some previous work reported scores based on
the similarity between composed representations
(Grefenstette and Sadrzadeh, 2011; Van de Cruys
et al., 2013), and others reported scores based on
the similarity between composed representations
and word representations of landmark verbs from
the dataset (Tsubaki et al., 2013; Van de Cruys et
al., 2013). For completeness, we report the scores
for both settings: SVO-SVO and SVO-V in Table 4.
The results show that the weighted addition
model with the non-linear function tanh (PAS-
CLBLM (Wadd
nl
)) is effective for the more com-
plex phrase task. While simple vector addition is
sufficient for phrases consisting of word pairs, it is
clear from our experimental results that they fall
short for more complex structures such as those
involved in the SVO task.
Our PAS-CLBLM (Wadd
nl
) model outperforms
the previous state-of-the-art scores for the SVO
task as reported by Tsubaki et al. (2013) and
Van de Cruys et al. (2013). As such, there are three
key points that we would like to emphasize:
(1) the difference of the training corpus size,
(2) the necessity of the pre-trained word vectors,
(3) the modularity of deep learning models.
Tsubaki et al. (2013) and Van de Cruys et al.
(2013) used the ukWaC corpus. This means our
model works better, despite using a considerably
smaller corpora. It should also be noted that, like
us, Grefenstette and Sadrzadeh (2011) used the
BNC corpus.
The model of Tsubaki et al. (2013) is based on
neural network language models which use syn-
tactic dependencies between verbs and their ob-
jects. While their novel model, which incorpo-
rates the idea of co-compositionality, works well
with pre-trained word vectors produced by exter-
nal models, it is not clear whether the pre-trained
vectors are required to achieve high scores. In
contrast, we have achieved state-of-the-art results
without the use of pre-trained word vectors.
Despite our model?s scalability, we trained 50-
dimensional vector representations for words and
their composition functions and achieved high
scores using this low dimensional vector space.
1551
model d AN NN VO SVO
Add
l
50 0.52 0.44 0.35 0.24
1000 0.51 0.51 0.43 0.31
Add
nl
50 0.52 0.46 0.45 0.24
1000 0.51 0.50 0.45 0.31
Wadd
l
50 0.48 0.39 0.34 0.21
1000 0.50 0.49 0.43 0.32
Wadd
nl
50 0.48 0.40 0.39 0.34
1000 0.51 0.48 0.48 0.34
Table 5: Comparison of the PAS-CLBLM between
d = 50 and d = 1000.
This maintains the possibility to incorporate re-
cently developed deep learning composition func-
tions into our models, such as recursive neural
tensor networks (Socher et al., 2013b) and co-
compositional neural networks (Tsubaki et al.,
2013). While such complex composition functions
slow down the training of compositional models,
richer information could be captured during train-
ing.
5.4 Effects of the Dimensionality
To see how the dimensionality of the word vectors
affects the scores, we trained the PAS-CLBLM for
each setting using 1,000-dimensional word vectors
and set the learning rate to 0.01. Table 5 shows
the scores for all four tasks. Note that we only re-
port the scores for the setting non-averaged SVO-
SVO here. As shown in Table 5, the scores consis-
tently improved with a few exceptions. The scores
? = 0.51 for the NN task and ? = 0.48 for the
VO task are the best results to date. However, the
score ? = 0.34 for the SVO task did not improve
by increasing the dimensionality. This means that
simply increasing the dimensionality of the word
vectors does not necessarily lead to better results
for complex phrases.
5.5 Effects of Bag-of-Words Contexts
Lastly, we trained the PAS-CLBLM without the
bag-of-words contexts described in Section 3.4
and used 50-dimensional word vectors. As can be
seen in Table 6, large score improvements were
observed only for the VO and SVO tasks by in-
cluding the bag-of-words contexts and the non-
linearity function. It is likely that the results de-
pend on how the bag-of-words contexts are con-
structed. However, we leave this line of analysis
as future work. Both adjective-noun and noun-
model BoW AN NN VO SVO
Add
l
w/ 0.52 0.44 0.35 0.24
w/o 0.48 0.46 0.38 0.23
Add
nl
w/ 0.52 0.46 0.45 0.24
w/o 0.50 0.47 0.41 0.15
Wadd
l
w/ 0.48 0.39 0.34 0.21
w/o 0.47 0.39 0.38 0.21
Wadd
nl
w/ 0.48 0.40 0.39 0.34
w/o 0.52 0.42 0.33 0.26
Table 6: Scores of the PAS-CLBLM with and
without BoW contexts.
noun phrase are noun phrases, and (subject-) verb-
object phrases can be regarded as complete sen-
tences. Therefore, different kinds of context infor-
mation might be required for both groups.
6 Qualitative Analysis on Composed
Vectors
An open question that remains is to what ex-
tent composition affects the representations pro-
duced by our PAS-CLBLM model. To evalu-
ate this we assigned a vector for each composed
representation. For example, the adjective-noun
dependency ?heavy rain? would be assigned an
independent vector. We added the most fre-
quent 100,000 adjective-noun, noun-noun, and
(subject-) verb-object tuples to the vocabulary and
the resulting vocabulary contained 400,000 to-
kens (100,000+3?100,000). A similar method
for treating frequent neighboring words as single
words was introduced by Mikolov et al. (2013b).
However, some dependencies, such as (subject-)
verb-object phrases, are not always captured when
considering only neighboring words.
Table 7 (No composition) shows some examples
of predicate-argument dependencies with their
closest neighbors in the vector space according
to the cosine similarity. The table shows that the
learned vectors of multiple words capture seman-
tic similarity. For example, the vector of ?heavy
rain? is close to the vectors of words which ex-
press the phenomena heavily raining. The vector
of ?new york? captures the concept of a major city.
The vectors of (subject-) verb-object dependencies
also capture the semantic similarity, which is the
main difference to previous approaches, such as
that of Mikolov et al. (2013b), which only consider
neighboring words. These results suggest that the
PAS-CLBLM can learn meaningful composition
1552
Query No composition Composition
rain rain
(AN) thunderstorm sunshine
heavy downpour storm
rain blizzard drizzle
much rain chill
general manager executive
(AN) vice president director
chief executive director representative
executive project manager officer
managing director administrator
second war war
(NN) plane crash world
world riot race
war last war holocaust
great war warfare
oslo york
(NN) paris toronto
new birmingham paris
york moscow edinburgh
madrid glasgow
make order make
(VO) carry survey allow
make pay tax demand
payment pay produce
impose tax bring
achieve objective solve
(VO) bridge gap alleviate
solve improve quality overcome
problem deliver information resolve
encourage development circumvent
hold meeting take
(SVO) event take place get
meeting end season win
take discussion take place put
place do work gain
Table 7: Nearest neighbor vectors for multiple
words. POS-tags are not shown for simplicity.
category predicate arg1 arg2
adj arg1 2.38 6.55 -
noun arg1 3.37 5.60 -
verb arg12 6.78 2.57 2.18
Table 8: L2-norms of the 50-dimensional weight
vectors of the composition function Wadd
nl
.
functions since the composition layers receive the
same error signal via backpropagation.
We then trained the PAS-CLBLM using Wadd
nl
to learn composition functions. Table 7 (Compo-
sition) shows the nearest neighbor words for each
composed vector, and as we can see, the learned
composition function emphasizes the head words
and captures some sort of semantic similarity. We
then inspected the L2-norms of the weight vectors
of the composition function. As shown in Table 8,
head words are strongly emphasized. Emphasiz-
ing head words is helpful in representing com-
posed meanings, but in the case of verbs it may
not always be sufficient. This can be observed in
Table 3 and Table 4, which demonstrates that verb-
related tasks are more difficult than noun-phrase
tasks.
While No composition captures the seman-
tic similarity well using independent parameters,
there is the issue of data sparseness. As the size of
the vocabulary increases, the number of tuples of
word dependencies increases rapidly. In this ex-
periment, we used only the 300,000 most frequent
tuples. In contrast to this, the learned composi-
tion functions can capture similar information us-
ing only word vectors and a small set of predicate
categories.
7 Conclusion and Future Work
We have presented a compositional log-bilinear
language model using predicate-argument struc-
tures that incorporates both bag-of-words and
dependency-based contexts. In our experiments
the learned composed vectors achieve state-of-the-
art scores for the task of measuring the semantic
similarity between short phrases. For the subject-
verb-object phrase task, the result is achieved
without any pre-trained word vectors using a cor-
pus an order of magnitude smaller than that of the
previous state of the art. For future work, we will
investigate how our models and the resulting vec-
tor representations can be helpful for other unsu-
pervised and/or supervised tasks.
Acknowledgments
We thank the anonymous reviewers for their help-
ful comments and suggestions. This work was
supported by JSPS KAKENHI Grant Number
13F03041.
References
Marco Baroni and Roberto Zamparelli. 2010. Nouns
are vectors, adjectives are matrices: Representing
adjective-noun constructions in semantic space. In
Proceedings of the 2010 Conference on Empirical
Methods in Natural Language Processing, pages
1183?1193.
Marco Baroni, Silvia Bernardini, Adriano Ferraresi,
and Eros Zanchetta. 2009. The WaCky Wide Web:
A Collection of Very Large Linguistically Processed
Web-Crawled Corpora. Language Resources and
Evaluation, 43(3):209?226.
Yoshua Bengio, Re?jean Ducharme, Pascal Vincent, and
Christian Jauvin. 2003. A Neural Probabilistic Lan-
1553
guage Model. Journal of Machine Learning Re-
search, 3:1137?1155.
William Blacoe and Mirella Lapata. 2012. A Com-
parison of Vector-based Representations for Seman-
tic Composition. In Proceedings of the 2012 Joint
Conference on Empirical Methods in Natural Lan-
guage Processing and Computational Natural Lan-
guage Learning, pages 546?556.
Ronan Collobert, Jason Weston, Le?on Bottou, Michael
Karlen, Koray Kavukcuoglu, and Pavel Kuksa.
2011. Natural Language Processing (Almost) from
Scratch. Journal of Machine Learning Research,
12:2493?2537.
John Duchi, Elad Hazan, and Yoram Singer. 2011.
Adaptive Subgradient Methods for Online Learning
and Stochastic Optimization. Journal of Machine
Learning Research, 12:2121?2159.
Katrin Erk and Sebastian Pado?. 2008. A Structured
Vector Space Model for Word Meaning in Context.
In Proceedings of the 2008 Conference on Empiri-
cal Methods in Natural Language Processing, pages
897?906.
Lev Finkelstein, Gabrilovich Evgenly, Matias Yossi,
Rivlin Ehud, Solan Zach, Wolfman Gadi, and Rup-
pin Eytan. 2001. Placing Search in Context: The
Concept Revisited. In Proceedings of the Tenth In-
ternational World Wide Web Conference.
John Rupert Firth. 1957. A synopsis of linguistic
theory 1930-55. In Studies in Linguistic Analysis,
pages 1?32.
Kartik Goyal, Sujay Kumar Jauhar, Huiying Li, Mrin-
maya Sachan, Shashank Srivastava, and Eduard
Hovy. 2013. A Structured Distributional Seman-
tic Model : Integrating Structure with Semantics. In
Proceedings of the Workshop on Continuous Vector
Space Models and their Compositionality, pages 20?
29.
Edward Grefenstette and Mehrnoosh Sadrzadeh. 2011.
Experimental Support for a Categorical Composi-
tional Distributional Model of Meaning. In Pro-
ceedings of the 2011 Conference on Empirical Meth-
ods in Natural Language Processing, pages 1394?
1404.
Kazuma Hashimoto, Makoto Miwa, Yoshimasa Tsu-
ruoka, and Takashi Chikayama. 2013. Simple Cus-
tomization of Recursive Neural Networks for Se-
mantic Relation Classification. In Proceedings of
the 2013 Conference on Empirical Methods in Nat-
ural Language Processing, pages 1372?1376.
Karl Moritz Hermann and Phil Blunsom. 2013. The
Role of Syntax in Vector Space Models of Composi-
tional Semantics. In Proceedings of the 51st Annual
Meeting of the Association for Computational Lin-
guistics (Volume 1: Long Papers), pages 894?904.
Eric Huang, Richard Socher, Christopher Manning,
and Andrew Ng. 2012. Improving Word Represen-
tations via Global Context and Multiple Word Proto-
types. In Proceedings of the 50th Annual Meeting of
the Association for Computational Linguistics (Vol-
ume 1: Long Papers), pages 873?882.
Dimitri Kartsaklis and Mehrnoosh Sadrzadeh. 2013.
Prior Disambiguation of Word Tensors for Con-
structing Sentence Vectors. In Proceedings of the
2013 Conference on Empirical Methods in Natural
Language Processing, pages 1590?1601.
Dimitri Kartsaklis, Mehrnoosh Sadrzadeh, and Stephen
Pulman. 2013. Separating Disambiguation from
Composition in Distributional Semantics. In Pro-
ceedings of 17th Conference on Natural Language
Learning (CoNLL), pages 114?123.
Omer Levy and Yoav Goldberg. 2014. Dependency-
Based Word Embeddings. In Proceedings of the
52nd Annual Meeting of the Association for Compu-
tational Linguistics (Volume 2: Short Papers), pages
302?308.
Tomas Mikolov, Kai Chen, Greg Corrado, and Jeffrey
Dean. 2013a. Efficient Estimation of Word Repre-
sentations in Vector Space. In Proceedings of Work-
shop at the International Conference on Learning
Representations.
Tomas Mikolov, Ilya Sutskever, Kai Chen, Greg S Cor-
rado, and Jeff Dean. 2013b. Distributed Represen-
tations of Words and Phrases and their Composition-
ality. In Advances in Neural Information Processing
Systems 26, pages 3111?3119.
Jeff Mitchell and Mirella Lapata. 2008. Vector-based
models of semantic composition. In Proceedings of
46th Annual Meeting of the Association for Com-
putational Linguistics: Human Language Technolo-
gies, pages 236?244.
Jeff Mitchell and Mirella Lapata. 2010. Composition
in Distributional Models of Semantics. Cognitive
Science, 34(8):1388?1439.
Yusuke Miyao and Jun?ichi Tsujii. 2008. Feature for-
est models for probabilistic HPSG parsing. Compu-
tational Linguistics, 34(1):35?80.
Andriy Mnih and Koray Kavukcuoglu. 2013. Learning
word embeddings efficiently with noise-contrastive
estimation. In Advances in Neural Information Pro-
cessing Systems 26, pages 2265?2273.
Andriy Mnih and Yee Whye Teh. 2012. A fast
and simple algorithm for training neural probabilis-
tic language models. In John Langford and Joelle
Pineau, editors, Proceedings of the 29th Interna-
tional Conference on Machine Learning (ICML-12),
ICML ?12, pages 1751?1758.
Denis Paperno, Nghia The Pham, and Marco Baroni.
2014. A practical and linguistically-motivated ap-
proach to compositional distributional semantics. In
1554
Proceedings of the 52nd Annual Meeting of the As-
sociation for Computational Linguistics (Volume 1:
Long Papers), pages 90?99.
Richard Socher, Brody Huval, Christopher D. Man-
ning, and Andrew Y. Ng. 2012. Semantic Compo-
sitionality through Recursive Matrix-Vector Spaces.
In Proceedings of the 2012 Joint Conference on
Empirical Methods in Natural Language Process-
ing and Computational Natural Language Learning,
pages 1201?1211.
Richard Socher, John Bauer, Christopher D. Manning,
and Ng Andrew Y. 2013a. Parsing with Compo-
sitional Vector Grammars. In Proceedings of the
51st Annual Meeting of the Association for Compu-
tational Linguistics (Volume 1: Long Papers), pages
455?465.
Richard Socher, Alex Perelygin, Jean Wu, Jason
Chuang, Christopher D. Manning, Andrew Ng, and
Christopher Potts. 2013b. Recursive Deep Mod-
els for Semantic Compositionality Over a Sentiment
Treebank. In Proceedings of the 2013 Conference
on Empirical Methods in Natural Language Pro-
cessing, pages 1631?1642.
Richard Socher, Quoc V. Le, Christopher D. Manning,
and Andrew Y. Ng. 2014. Grounded Compositional
Semantics for Finding and Describing Images with
Sentences. Transactions of the Association for Com-
putational Linguistics, 2:207?218.
Stefan Thater, Hagen Fu?rstenau, and Manfred Pinkal.
2010. Contextualizing Semantic Representations
Using Syntactically Enriched Vector Models. In
Proceedings of the 48th Annual Meeting of the As-
sociation for Computational Linguistics, pages 948?
957.
Masashi Tsubaki, Kevin Duh, Masashi Shimbo, and
Yuji Matsumoto. 2013. Modeling and Learning Se-
mantic Co-Compositionality through Prototype Pro-
jections and Neural Networks. In Proceedings of the
2013 Conference on Empirical Methods in Natural
Language Processing, pages 130?140.
Joseph Turian, Lev-Arie Ratinov, and Yoshua Bengio.
2010. Word Representations: A Simple and General
Method for Semi-Supervised Learning. In Proceed-
ings of the 48th Annual Meeting of the Association
for Computational Linguistics, pages 384?394.
Peter D. Turney and Patrick Pantel. 2010. From Fre-
quency to Meaning: Vector Space Models of Se-
mantics. Journal of Artificial Intelligence Research,
37(1):141?188.
Tim Van de Cruys, Thierry Poibeau, and Anna Korho-
nen. 2013. A Tensor-based Factorization Model of
Semantic Compositionality. In Proceedings of the
2013 Conference of the North American Chapter of
the Association for Computational Linguistics: Hu-
man Language Technologies, pages 1142?1151.
1555
