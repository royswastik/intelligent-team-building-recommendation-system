Dynamic programming for parsing and estimation of
stochastic unication-based grammars?
Stuart Geman
Division of Applied Mathematics
Brown University
geman@dam.brown.edu
Mark Johnson
Cognitive and Linguistic Sciences
Brown University
Mark Johnson@Brown.edu
Abstract
Stochastic unification-based grammars
(SUBGs) define exponential distributions
over the parses generated by a unification-
based grammar (UBG). Existing algo-
rithms for parsing and estimation require
the enumeration of all of the parses of a
string in order to determine the most likely
one, or in order to calculate the statis-
tics needed to estimate a grammar from
a training corpus. This paper describes a
graph-based dynamic programming algo-
rithm for calculating these statistics from
the packed UBG parse representations of
Maxwell and Kaplan (1995) which does
not require enumerating all parses. Like
many graphical algorithms, the dynamic
programming algorithm?s complexity is
worst-case exponential, but is often poly-
nomial. The key observation is that by
using Maxwell and Kaplan packed repre-
sentations, the required statistics can be
rewritten as either the max or the sum of
a product of functions. This is exactly
the kind of problem which can be solved
by dynamic programming over graphical
models.
? We would like to thank Eugene Charniak, Miyao
Yusuke, Mark Steedman as well as Stefan Riezler and the team
at PARC; naturally all errors remain our own. This research was
supported by NSF awards DMS 0074276 and ITR IIS 0085940.
1 Introduction
Stochastic Unification-Based Grammars (SUBGs)
use log-linear models (also known as exponential or
MaxEnt models and Markov Random Fields) to de-
fine probability distributions over the parses of a uni-
fication grammar. These grammars can incorporate
virtually all kinds of linguistically important con-
straints (including non-local and non-context-free
constraints), and are equipped with a statistically
sound framework for estimation and learning.
Abney (1997) pointed out that the non-context-
free dependencies of a unification grammar require
stochastic models more general than Probabilis-
tic Context-Free Grammars (PCFGs) and Markov
Branching Processes, and proposed the use of log-
linear models for defining probability distributions
over the parses of a unification grammar. Un-
fortunately, the maximum likelihood estimator Ab-
ney proposed for SUBGs seems computationally in-
tractable since it requires statistics that depend on
the set of all parses of all strings generated by the
grammar. This set is infinite (so exhaustive enumer-
ation is impossible) and presumably has a very com-
plex structure (so sampling estimates might take an
extremely long time to converge).
Johnson et al (1999) observed that parsing and
related tasks only require conditional distributions
over parses given strings, and that such conditional
distributions are considerably easier to estimate than
joint distributions of strings and their parses. The
conditional maximum likelihood estimator proposed
by Johnson et al requires statistics that depend on
the set of all parses of the strings in the training cor-
                Computational Linguistics (ACL), Philadelphia, July 2002, pp. 279-286.
                         Proceedings of the 40th Annual Meeting of the Association for
pus. For most linguistically realistic grammars this
set is finite, and for moderate sized grammars and
training corpora this estimation procedure is quite
feasible.
However, our recent experiments involve training
from the Wall Street Journal Penn Tree-bank, and
repeatedly enumerating the parses of its 50,000 sen-
tences is quite time-consuming. Matters are only
made worse because we have moved some of the
constraints in the grammar from the unification com-
ponent to the stochastic component. This broadens
the coverage of the grammar, but at the expense of
massively expanding the number of possible parses
of each sentence.
In the mid-1990s unification-based parsers were
developed that do not enumerate all parses of a string
but instead manipulate and return a ?packed? rep-
resentation of the set of parses. This paper de-
scribes how to find the most probable parse and
the statistics required for estimating a SUBG from
the packed parse set representations proposed by
Maxwell III and Kaplan (1995). This makes it pos-
sible to avoid explicitly enumerating the parses of
the strings in the training corpus.
The methods proposed here are analogues of
the well-known dynamic programming algorithms
for Probabilistic Context-Free Grammars (PCFGs);
specifically the Viterbi algorithm for finding the
most probable parse of a string, and the Inside-
Outside algorithm for estimating a PCFG from un-
parsed training data.1 In fact, because Maxwell and
Kaplan packed representations are just Truth Main-
tenance System (TMS) representations (Forbus and
de Kleer, 1993), the statistical techniques described
here should extend to non-linguistic applications of
TMSs as well.
Dynamic programming techniques have
been applied to log-linear models before.
Lafferty et al (2001) mention that dynamic
programming can be used to compute the statistics
required for conditional estimation of log-linear
models based on context-free grammars where
the properties can include arbitrary functions of
the input string. Miyao and Tsujii (2002) (which
1However, because we use conditional estimation, also
known as discriminative training, we require at least some dis-
criminating information about the correct parse of a string in
order to estimate a stochastic unification grammar.
appeared after this paper was accepted) is the closest
related work we know of. They describe a technique
for calculating the statistics required to estimate a
log-linear parsing model with non-local properties
from packed feature forests.
The rest of this paper is structured as follows.
The next section describes unification grammars
and Maxwell and Kaplan packed representation.
The following section reviews stochastic unifica-
tion grammars (Abney, 1997) and the statistical
quantities required for efficiently estimating such
grammars from parsed training data (Johnson et al,
1999). The final substantive section of this paper
shows how these quantities can be defined directly
in terms of the Maxwell and Kaplan packed repre-
sentations.
The notation used in this paper is as follows. Vari-
ables are written in upper case italic, e.g., X,Y , etc.,
the sets they range over are written in script, e.g.,
X ,Y , etc., while specific values are written in lower
case italic, e.g., x, y, etc. In the case of vector-valued
entities, subscripts indicate particular components.
2 Maxwell and Kaplan packed
representations
This section characterises the properties of unifica-
tion grammars and the Maxwell and Kaplan packed
parse representations that will be important for what
follows. This characterisation omits many details
about unification grammars and the algorithm by
which the packed representations are actually con-
structed; see Maxwell III and Kaplan (1995) for de-
tails.
A parse generated by a unification grammar is a
nite subset of a set F of features. Features are parse
fragments, e.g., chart edges or arcs from attribute-
value structures, out of which the packed representa-
tions are constructed. For this paper it does not mat-
ter exactly what features are, but they are intended
to be the atomic entities manipulated by a dynamic
programming parsing algorithm. A grammar defines
a set ? of well-formed or grammatical parses. Each
parse ? ? ? is associated with a string of words
Y (?) called its yield. Note that except for trivial
grammars F and ? are infinite.
If y is a string, then let ?(y) = {? ? ?|Y (?) =
y} and F(y) = ????(y){f ? ?}. That is, ?(y) is
the set of parses of a string y and F(y) is the set of
features appearing in the parses of y. In the gram-
mars of interest here ?(y) and hence also F(y) are
finite.
Maxwell and Kaplan?s packed representations of-
ten provide a more compact representation of the
set of parses of a sentence than would be obtained
by merely listing each parse separately. The intu-
ition behind these packed representations is that for
most strings y, many of the features in F(y) occur
in many of the parses ?(y). This is often the case
in natural language, since the same substructure can
appear as a component of many different parses.
Packed feature representations are defined in
terms of conditions on the values assigned to a vec-
tor of variables X . These variables have no direct
linguistic interpretation; rather, each different as-
signment of values to these variables identifies a set
of features which constitutes one of the parses in
the packed representation. A condition a on X is
a function from X to {0, 1}. While for uniformity
we write conditions as functions on the entire vec-
tor X , in practice Maxwell and Kaplan?s approach
produces conditions whose value depends only on a
few of the variables in X , and the efficiency of the
algorithms described here depends on this.
A packed representation of a finite set of parses is
a quadruple R = (F ?, X,N, ?), where:
? F ? ? F(y) is a finite set of features,
? X is a finite vector of variables, where each
variable X` ranges over the finite set X`,
? N is a finite set of conditions on X called the
no-goods,2 and
? ? is a function that maps each feature f ? F ?
to a condition ?f on X .
A vector of values x satises the no-goods N iff
N(x) = 1, where N(x) = ???N ?(x). Each x
that satisfies the no-goods identies a parse ?(x) =
{f ? F ?|?f (x) = 1}, i.e., ? is the set of features
whose conditions are satisfied by x. We require that
each parse be identified by a unique value satisfying
2The name ?no-good? comes from the TMS literature, and
was used by Maxwell and Kaplan. However, here the no-goods
actually identify the good variable assignments.
the no-goods. That is, we require that:
?x, x? ? X if N(x) = N(x?) = 1 and
?(x) = ?(x?) then x = x? (1)
Finally, a packed representation R represents the
set of parses ?(R) that are identified by values
that satisfy the no-goods, i.e., ?(R) = {?(x)|x ?
X , N(x) = 1}.
Maxwell III and Kaplan (1995) describes a pars-
ing algorithm for unification-based grammars that
takes as input a string y and returns a packed rep-
resentation R such that ?(R) = ?(y), i.e., R rep-
resents the set of parses of the string y. The SUBG
parsing and estimation algorithms described in this
paper use Maxwell and Kaplan?s parsing algorithm
as a subroutine.
3 Stochastic Unification-Based Grammars
This section reviews the probabilistic framework
used in SUBGs, and describes the statistics that
must be calculated in order to estimate the pa-
rameters of a SUBG from parsed training data.
For a more detailed exposition and descriptions
of regularization and other important details, see
Johnson et al (1999).
The probability distribution over parses is defined
in terms of a finite vector g = (g1, . . . , gm) of
properties. A property is a real-valued function of
parses ?. Johnson et al (1999) placed no restric-
tions on what functions could be properties, permit-
ting properties to encode arbitrary global informa-
tion about a parse. However, the dynamic program-
ming algorithms presented here require the informa-
tion encoded in properties to be local with respect to
the features F used in the packed parse representa-
tion. Specifically, we require that properties be de-
fined on features rather than parses, i.e., each feature
f ? F is associated with a finite vector of real values
(g1(f), . . . , gm(f)) which define the property func-
tions for parses as follows:
gk(?) =
?
f??
gk(f), for k = 1 . . . m. (2)
That is, the property values of a parse are the sum
of the property values of its features. In the usual
case, some features will be associated with a single
property (i.e., gk(f) is equal to 1 for a specific value
of k and 0 otherwise), and other features will be as-
sociated with no properties at all (i.e., g(f) = 0).
This requires properties be very local with re-
spect to features, which means that we give up the
ability to define properties arbitrarily. Note how-
ever that we can still encode essentially arbitrary
linguistic information in properties by adding spe-
cialised features to the underlying unification gram-
mar. For example, suppose we want a property that
indicates whether the parse contains a reduced rela-
tive clauses headed by a past participle (such ?gar-
den path? constructions are grammatical but often
almost incomprehensible, and alternative parses not
including such constructions would probably be pre-
ferred). Under the current definition of properties,
we can introduce such a property by modifying the
underlying unification grammar to produce a certain
?diacritic? feature in a parse just in case the parse ac-
tually contains the appropriate reduced relative con-
struction. Thus, while properties are required to be
local relative to features, we can use the ability of
the underlying unification grammar to encode essen-
tially arbitrary non-local information in features to
introduce properties that also encode non-local in-
formation.
A Stochastic Unification-Based Grammar is a
triple (U, g, ?), where U is a unification grammar
that defines a set ? of parses as described above,
g = (g1, . . . , gm) is a vector of property functions as
just described, and ? = (?1, . . . , ?m) is a vector of
non-negative real-valued parameters called property
weights. The probability P?(?) of a parse ? ? ? is:
P?(?) =
W?(?)
Z?
, where:
W?(?) =
m
?
j=1
?gj(?)j , and
Z? =
?
????
W?(??)
Intuitively, if gj(?) is the number of times that prop-
erty j occurs in ? then ?j is the ?weight? or ?cost? of
each occurrence of property j and Z? is a normal-
ising constant that ensures that the probability of all
parses sums to 1.
Now we discuss the calculation of several impor-
tant quantities for SUBGs. In each case we show
that the quantity can be expressed as the value that
maximises a product of functions or else as the sum
of a product of functions, each of which depends
on a small subset of the variables X . These are the
kinds of quantities for which dynamic programming
graphical model algorithms have been developed.
3.1 The most probable parse
In parsing applications it is important to be able to
extract the most probable (or MAP) parse ??(y) of
string y with respect to a SUBG. This parse is:
??(y) = argmax
???(y)
W?(?)
Given a packed representation (F ?, X,N, ?) for the
parses ?(y), let x?(y) be the x that identifies ??(y).
Since W?(??(y)) > 0, it can be shown that:
x?(y) = argmax
x?X
N(x)
m
?
j=1
?gj(?(x))j
= argmax
x?X
N(x)
m
?
j=1
?
?
f??(x) gj(f)
j
= argmax
x?X
N(x)
m
?
j=1
?
?
f?F? ?f (x)gj(f)
j
= argmax
x?X
N(x)
m
?
j=1
?
f?F ?
??f (x)gj(f)j
= argmax
x?X
N(x)
?
f?F ?
?
?
m
?
j=1
?gj(f)j
?
?
?f (x)
= argmax
x?X
?
??N
?(x)
?
f?F ?
h?,f (x) (3)
where h?,f (x) = ?mj=1 ?gj(f)j if ?f (x) = 1 and
h?,f (x) = 1 if ?f (x) = 0. Note that h?,f (x) de-
pends on exactly the same variables in X as ?f does.
As (3) makes clear, finding x?(y) involves maximis-
ing a product of functions where each function de-
pends on a subset of the variables X . As explained
below, this is exactly the kind of maximisation that
can be solved using graphical model techniques.
3.2 Conditional likelihood
We now turn to the estimation of the property
weights ? from a training corpus of parsed data D =
(?1, . . . , ?n). As explained in Johnson et al (1999),
one way to do this is to find the ? that maximises the
conditional likelihood of the training corpus parses
given their yields. (Johnson et al actually maximise
conditional likelihood regularized with a Gaussian
prior, but for simplicity we ignore this here). If yi is
the yield of the parse ?i, the conditional likelihood
of the parses given their yields is:
LD(?) =
n
?
i=1
W?(?i)
Z?(?(yi))
where ?(y) is the set of parses with yield y and:
Z?(S) =
?
??S
W?(?).
Then the maximum conditional likelihood estimate
?? of ? is ?? = argmax? LD(?).
Now calculating W?(?i) poses no computational
problems, but since ?(yi) (the set of parses for yi)
can be large, calculating Z?(?(yi)) by enumerating
each ? ? ?(yi) can be computationally expensive.
However, there is an alternative method for calcu-
lating Z?(?(yi)) that does not involve this enumera-
tion. As noted above, for each yield yi, i = 1, . . . , n,
Maxwell?s parsing algorithm returns a packed fea-
ture structure Ri that represents the parses of yi, i.e.,
?(yi) = ?(Ri). A derivation parallel to the one for
(3) shows that for R = (F ?, X,N, ?):
Z?(?(R)) =
?
x?X
?
??N
?(x)
?
f?F ?
h?,f (x) (4)
(This derivation relies on the isomorphism between
parses and variable assignments in (1)). It turns out
that this type of sum can also be calculated using
graphical model techniques.
3.3 Conditional Expectations
In general, iterative numerical procedures are re-
quired to find the property weights ? that maximise
the conditional likelihood LD(?). While there are
a number of different techniques that can be used,
all of the efficient techniques require the calculation
of conditional expectations E?[gk|yi] for each prop-
erty gk and each sentence yi in the training corpus,
where:
E?[g|y] =
?
???(y)
g(?)P?(?|y)
=
?
???(y) g(?)W?(?)
Z?(?(y))
For example, the Conjugate Gradient algorithm,
which was used by Johnson et al, requires the cal-
culation not just of LD(?) but also its derivatives
?LD(?)/??k. It is straight-forward to show:
?LD(?)
??k
= LD(?)?k
n
?
i=1
(gk(?i) ? E?[gk|yi]) .
We have just described the calculation of LD(?),
so if we can calculate E?[gk|yi] then we can calcu-
late the partial derivatives required by the Conjugate
Gradient algorithm as well.
Again, let R = (F ?, X,N, ?) be a packed repre-
sentation such that ?(R) = ?(yi). First, note that
(2) implies that:
E?[gk|yi] =
?
f?F ?
gk(f) P({? : f ? ?}|yi).
Note that P({? : f ? ?}|yi) involves the sum of
weights over all x ? X subject to the conditions
that N(x) = 1 and ?f (x) = 1. Thus P({? : f ?
?}|yi) can also be expressed in a form that is easy
to evaluate using graphical techniques.
Z?(?(R))P?({? : f ? ?}|yi)
=
?
x?X
?f (x)
?
??N
?(x)
?
f ??F ?
h?,f ?(x) (5)
4 Graphical model calculations
In this section we briefly review graphical model
algorithms for maximising and summing products
of functions of the kind presented above. It turns
out that the algorithm for maximisation is a gener-
alisation of the Viterbi algorithm for HMMs, and
the algorithm for computing the summation in (5)
is a generalisation of the forward-backward algo-
rithm for HMMs (Smyth et al, 1997). Viewed
abstractly, these algorithms simplify these expres-
sions by moving common factors over the max or
sum operators respectively. These techniques are
now relatively standard; the most well-known ap-
proach involves junction trees (Pearl, 1988; Cow-
ell, 1999). We adopt the approach approach de-
scribed by Geman and Kochanek (2000), which is
a straightforward generalization of HMM dynamic
programming with minimal assumptions and pro-
gramming overhead. However, in principle any of
the graphical model computational algorithms can
be used.
The quantities (3), (4) and (5) involve maximisa-
tion or summation over a product of functions, each
of which depends only on the values of a subset of
the variables X . There are dynamic programming
algorithms for calculating all of these quantities, but
for reasons of space we only describe an algorithm
for finding the maximum value of a product of func-
tions. These graph algorithms are rather involved.
It may be easier to follow if one reads Example 1
before or in parallel with the definitions below.
To explain the algorithm we use the following no-
tation. If x and x? are both vectors of length m
then x =j x? iff x and x? disagree on at most their
jth components, i.e., xk = x?k for k = 1, . . . , j ?
1, j + 1, . . . m. If f is a function whose domain
is X , we say that f depends on the set of variables
d(f) = {Xj |?x, x? ? X , x =j x?, f(x) 6= f(x?)}.
That is, Xj ? d(f) iff changing the value of Xj can
change the value of f .
The algorithm relies on the fact that the variables
in X = (X1, . . . , Xn) are ordered (e.g., X1 pre-
cedes X2, etc.), and while the algorithm is correct
for any variable ordering, its efficiency may vary
dramatically depending on the ordering as described
below. Let H be any set of functions whose do-
mains are X . We partition H into disjoint subsets
H1, . . . ,Hn+1, where Hj is the subset of H that de-
pend on Xj but do not depend on any variables or-
dered before Xj , and Hn+1 is the subset of H that do
not depend on any variables at all (i.e., they are con-
stants).3 That is, Hj = {H ? H|Xj ? d(H),?i <
j Xi 6? d(H)} and Hn+1 = {H ? H|d(H) = ?}.
As explained in section 3.1, there is a set of func-
tions A such that the quantities we need to calculate
have the general form:
Mmax = maxx?X
?
A?A
A(x) (6)
x? = argmax
x?X
?
A?A
A(x). (7)
Mmax is the maximum value of the product expres-
sion while x? is the value of the variables at which the
maximum occurs. In a SUBG parsing application x?
identifies the MAP parse.
3Strictly speaking this does not necessarily define a parti-
tion, as some of the subsetsHj may be empty.
The procedure depends on two sequences of func-
tions Mi, i = 1, . . . , n + 1 and Vi, i = 1, . . . , n.
Informally, Mi is the maximum value attained by
the subset of the functions A that depend on one of
the variables X1, . . . , Xi, and Vi gives information
about the value of Xi at which this maximum is at-
tained.
To simplify notation we write these functions as
functions of the entire set of variables X , but usu-
ally depend on a much smaller set of variables. The
Mi are real valued, while each Vi ranges over Xi.
Let M = {M1, . . . ,Mn}. Recall that the sets of
functions A and M can be both be partitioned into
disjoint subsets A1, . . . ,An+1 and M1, . . . ,Mn+1
respectively on the basis of the variables each Ai
and Mi depend on. The definition of the Mi and
Vi, i = 1, . . . , n is as follows:
Mi(x) = max
x??X
s.t. x?=ix
?
A?Ai
A(x?)
?
M?Mi
M(x?) (8)
Vi(x) = argmax
x??X
s.t. x?=ix
?
A?Ai
A(x?)
?
M?Mi
M(x?)
Mn+1 receives a special definition, since there is no
variable Xn+1.
Mn+1 =
?
?
?
A?An+1
A
?
?
?
?
?
M?Mn+1
M
?
? (9)
The definition of Mi in (8) may look circular (since
M appears in the right-hand side), but in fact it is
not. First, note that Mi depends only on variables
ordered after Xi, so if Mj ? Mi then j < i. More
specifically,
d(Mi) =
?
?
?
A?Ai
d(A) ?
?
M?Mi
d(M)
?
? \ {Xi}.
Thus we can compute the Mi in the order
M1, . . . ,Mn+1, inserting Mi into the appropriate set
Mk, where k > i, when Mi is computed.
We claim that Mmax = Mn+1. (Note that Mn+1
and Mn are constants, since there are no variables
ordered after Xn). To see this, consider the tree T
whose nodes are the Mi, and which has a directed
edge from Mi to Mj iff Mi ? Mj (i.e., Mi appears
in the right hand side of the definition (8) of Mj).
T has a unique root Mn+1, so there is a path from
every Mi to Mn+1. Let i ? j iff there is a path
from Mi to Mj in this tree. Then a simple induction
shows that Mj is a function from d(Mj) to a max-
imisation over each of the variables Xi where i ? j
of ?i?j,A?Ai A.Further, it is straightforward to show that Vi(x?) =
x?i (the value x? assigns to Xi). By the same argu-
ments as above, d(Vi) only contains variables or-
dered after Xi, so Vn = x?n. Thus we can evaluate
the Vi in the order Vn, . . . , V1 to find the maximising
assignment x?.
Example 1 Let X = { X1, X2, X3, X4, X5,
X6, X7} and set A = {a(X1, X3), b(X2, X4),
c(X3, X4, X5), d(X4, X5), e(X6, X7)}. We can
represent the sharing of variables in A by means of a
undirected graph GA, where the nodes of GA are the
variables X and there is an edge in GA connecting
Xi to Xj iff ?A ? A such that both Xi, Xj ? d(A).
GA is depicted below.
  
  
X1 X3 X5 X6
X2 X4 X7
r r r
rr
r
r
Starting with the variable X1, we compute M1
and V1:
M1(x3) = maxx1?X1
a(x1, x3)
V1(x3) = argmax
x1?X1
a(x1, x3)
We now proceed to the variable X2.
M2(x4) = maxx2?X2 b(x2, x4)
V2(x4) = argmax
x2?X2
b(x2, x4)
Since M1 belongs to M3, it appears in the denition
of M3.
M3(x4, x5) = maxx3?X3
c(x3, x4, x5)M1(x3)
V3(x4, x5) = argmax
x3?X3
c(x3, x4, x5)M1(x3)
Similarly, M4 is dened in terms of M2 and M3.
M4(x5) = maxx4?X4 d(x4, x5)M2(x4)M3(x4, x5)
V4(x5) = argmax
x4?X4
d(x4, x5)M2(x4)M3(x4, x5)
Note that M5 is a constant, reecting the fact that
in GA the node X5 is not connected to any node or-
dered after it.
M5 = maxx5?X5 M4(x5)
V5 = argmax
x5?X5
M4(x5)
The second component is dened in the same way:
M6(x7) = maxx6?X6 e(x6, x7)
V6(x7) = argmax
x6?X6
e(x6, x7)
M7 = maxx7?X7 M6(x7)
V7 = argmax
x7?X7
M6(x7)
The maximum value for the product M8 = Mmax is
dened in terms of M5 and M7.
Mmax = M8 = M5M7
Finally, we evaluate V7, . . . , V1 to nd the maximis-
ing assignment x?.
x?7 = V7
x?6 = V6(x?7)
x?5 = V5
x?4 = V4(x?5)
x?3 = V3(x?4, x?5)
x?2 = V2(x?4)
x?1 = V1(x?3)
We now briefly consider the computational com-
plexity of this process. Clearly, the number of steps
required to compute each Mi is a polynomial of or-
der |d(Mi)|+1, since we need to enumerate all pos-
sible values for the argument variables d(Mi) and
for each of these, maximise over the set Xi. Fur-
ther, it is easy to show that in terms of the graph GA,
d(Mj) consists of those variables Xk, k > j reach-
able by a path starting at Xj and all of whose nodes
except the last are variables that precede Xj .
Since computational effort is bounded above by a
polynomial of order |d(Mi)|+ 1, we seek a variable
ordering that bounds the maximum value of |d(Mi)|.
Unfortunately, finding the ordering that minimises
the maximum value of |d(Mi)| is an NP-complete
problem. However, there are several efficient heuris-
tics that are reputed in graphical models community
to produce good visitation schedules. It may be that
they will perform well in the SUBG parsing applica-
tions as well.
5 Conclusion
This paper shows how to apply dynamic program-
ming methods developed for graphical models to
SUBGs to find the most probable parse and to ob-
tain the statistics needed for estimation directly from
Maxwell and Kaplan packed parse representations.
i.e., without expanding these into individual parses.
The algorithm rests on the observation that so long
as features are local to the parse fragments used in
the packed representations, the statistics required for
parsing and estimation are the kinds of quantities
that dynamic programming algorithms for graphical
models can perform. Since neither Maxwell and Ka-
plan?s packed parsing algorithm nor the procedures
described here depend on the details of the underly-
ing linguistic theory, the approach should apply to
virtually any kind of underlying grammar.
Obviously, an empirical evaluation of the algo-
rithms described here would be extremely useful.
The algorithms described here are exact, but be-
cause we are working with unification grammars
and apparently arbitrary graphical models we can-
not polynomially bound their computational com-
plexity. However, it seems reasonable to expect
that if the linguistic dependencies in a sentence typ-
ically factorize into largely non-interacting cliques
then the dynamic programming methods may offer
dramatic computational savings compared to current
methods that enumerate all possible parses.
It might be interesting to compare these dy-
namic programming algorithms with a standard
unification-based parser using a best-first search
heuristic. (To our knowledge such an approach has
not yet been explored, but it seems straightforward:
the figure of merit could simply be the sum of the
weights of the properties of each partial parse?s frag-
ments). Because such parsers prune the search space
they cannot guarantee correct results, unlike the al-
gorithms proposed here. Such a best-first parser
might be accurate when parsing with a trained gram-
mar, but its results may be poor at the beginning
of parameter weight estimation when the parameter
weight estimates are themselves inaccurate.
Finally, it would be extremely interesting to com-
pare these dynamic programming algorithms to
the ones described by Miyao and Tsujii (2002). It
seems that the Maxwell and Kaplan packed repre-
sentation may permit more compact representations
than the disjunctive representations used by Miyao
et al, but this does not imply that the algorithms
proposed here are more efficient. Further theoreti-
cal and empirical investigation is required.
References
Steven Abney. 1997. Stochastic Attribute-Value Grammars.
Computational Linguistics, 23(4):597?617.
Robert Cowell. 1999. Introduction to inference for Bayesian
networks. In Michael Jordan, editor, Learning in Graphi-
cal Models, pages 9?26. The MIT Press, Cambridge, Mas-
sachusetts.
Kenneth D. Forbus and Johan de Kleer. 1993. Building problem
solvers. The MIT Press, Cambridge, Massachusetts.
Stuart Geman and Kevin Kochanek. 2000. Dynamic program-
ming and the representation of soft-decodable codes. Tech-
nical report, Division of Applied Mathematics, Brown Uni-
versity.
Mark Johnson, Stuart Geman, Stephen Canon, Zhiyi Chi, and
Stefan Riezler. 1999. Estimators for stochastic ?unification-
based? grammars. In The Proceedings of the 37th Annual
Conference of the Association for Computational Linguis-
tics, pages 535?541, San Francisco. Morgan Kaufmann.
John Lafferty, Andrew McCallum, and Fernando Pereira. 2001.
Conditional Random Fields: Probabilistic models for seg-
menting and labeling sequence data. In Machine Learn-
ing: Proceedings of the Eighteenth International Conference
(ICML 2001), Stanford, California.
John T. Maxwell III and Ronald M. Kaplan. 1995. A method
for disjunctive constraint satisfaction. In Mary Dalrymple,
Ronald M. Kaplan, John T. Maxwell III, and Annie Zae-
nen, editors, Formal Issues in Lexical-Functional Grammar,
number 47 in CSLI Lecture Notes Series, chapter 14, pages
381?481. CSLI Publications.
Yusuke Miyao and Jun?ichi Tsujii. 2002. Maximum entropy
estimation for feature forests. In Proceedings of Human
Language Technology Conference 2002, March.
Judea Pearl. 1988. Probabalistic Reasoning in Intelligent Sys-
tems: Networks of Plausible Inference. Morgan Kaufmann,
San Mateo, California.
Padhraic Smyth, David Heckerman, and Michael Jordan. 1997.
Probabilistic Independence Networks for Hidden Markov
Models. Neural Computation, 9(2):227?269.
