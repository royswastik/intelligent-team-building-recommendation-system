Proceedings of the 7th SIGdial Workshop on Discourse and Dialogue, pages 54?59,
Sydney, July 2006. c?2006 Association for Computational Linguistics
Resolution of Referents Groupings in Practical Dialogues 
 
 
Alexandre Denis,  Guillaume Pitel,  Matthieu Quignard 
LORIA  
BP239 F-54206 Vandoeuvre-l?s-nancy, France 
denis@loria.fr,pitel@loria.fr,quignard@loria.fr 
 
  
Abstract 
This paper presents an extension to the 
Reference Domain Theory (Salmon-Alt, 
2001) in order to solve plural references. 
While this theory doesn?t take plural 
reference into account in its original 
form, this paper shows how several 
entities can be grouped together by 
building a new domain and how they can 
be accessed later on. We introduce the 
notion of super-domain, representing the 
access structure to all the plural referents 
of a given type. 
1 Introduction 
In the course of a discourse or a dialogue, 
referents introduced separately could be 
referenced with a single plural expression 
(pronoun, demonstratives, etc.). The grouping of 
these referents may depend on many factors: it 
may be explicit if they were syntactically 
coordinated or juxtaposed or implicit if they just 
share common semantic features (Eschenbach et 
al., 1989). Time is also an important factor while 
it may be difficult to group old mentioned 
referents with new ones. Because of this 
multiplicity of factors, choosing the right 
discursive grouping for a referential plural 
expression is ambiguous, and this ambiguity 
needs to be explicitly described.  
We present a model of grouping based on 
reference domains theory (Salmon-Alt, 2001) 
that considers that a reference operation consists 
of extracting a referent in a domain. However the 
original theory barely takes into account plural 
reference. This paper shows how several entities 
can be grouped together by building a new 
domain and how they can be accessed later on. It 
introduces also the notion of super-domain D+ 
that represents the access structure to all the 
plural referents of type D. This work is currently 
being implemented and evaluated in the MEDIA 
project of the EVALDA framework, a national 
french understanding evaluation campaign 
(Devillers, 2004). 
2 Groupings of Referents  
Several kinds of clues can specify that referents 
should be grouped together, or at least could be 
grouped together. These clues may occur at 
several language levels, from the noun phrase 
level to the rhetorical structure level. We have 
not explored in detail the different ways of 
groupings entities together in a discourse or 
dialogue. What is described here are just some of 
the phenomenon we got confronted with while 
developing a reference resolution module for a 
dialogue understanding system. 
 Explicit Coordination - The most basic 
way to explicitly express the grouping of two 
or more referents is using a connector such as 
and, or, as well as, etc.  
?Good afternoon, I would like to book a 
single room and a double room? 
 Implicit Sentential Coordination - An 
implicit coordination occurs when two or 
more referents of the same kind are present in 
one sentence, without explicit connector 
between them. ?Does the hotel de la gare 
have a restaurant, like the Holiday Inn?? 
 Implicit Discursive Coordination ? 
Such a coordination occurs when several 
reference are evoked in separate sentences. 
The grouping must be done based on 
rhetorical structuring. Here we consider short 
pieces of dialogue, admitting only one level 
of implicit discursive coordination.  ?I would 
like an hotel close to the sea... I also need an 
hotel downtown... And the hotels have to 
accept dogs.? 
54
 Repetitions/Specifications ? In some 
particular cases, groupings make explicit a 
previous expression. For instance ?Two 
rooms. A single room, a double room?. 
3 Reference Domain Theory 
We are willing to try a pragmatic approach to 
reference resolution in practical multimodal 
dialogues (Gieselman, 2004). For example we 
need to process frequent phenomena like 
ordinals for choosing in a list (discursive, or 
visual) or otherness when re-evoking old 
referents. Hence keeping the track of the way the 
context is modified when introducing a referent 
or referring, is mandatory. The Reference 
Domains Theory (Salmon-Alt, 2001) supposes 
that every act of reference is related to a certain 
domain of interpretation. It endorses the 
cognitive grammar concept of domain, defined  
as a cognitive structure presupposed by the 
semantics of the expression (Kumar et al, 2003).  
In other words, a referring expression has to be 
interpreted in a given domain, highlighting and 
specifying a particular referent in this domain. A 
reference domain is composed of a group of 
entities in the hearer?s memory which can be 
discursive referents, visual objects, or concepts. 
It describes how each entity could be addressed 
through a referential expression.  
This theory views the referring process as a 
dynamic extraction of a referent in a domain 
instead of a binding between two entities 
(Salmon-Alt, 2000). Hence doing a reference act 
consists in isolating a particular entity from other 
rejected candidates, amongst all the accessible 
entities composing the domain (Olson, 1970). 
This dynamic discrimination relies on projecting 
an access structure focusing the referent in the 
domain.  The domain then becomes salient for 
further interpretations. The preferences for 
choosing a suitable domain are inspired from the 
Relevance theory (Sperber & Wilson, 1986) 
taking into account such focalization and 
salience.  
Landragin & Romary (2003) have also studied 
the usage of reference domains in order to model 
a visual scene. The grouping factors for visual 
objects are those given by the Gestalt theory, 
proximity, similarity, and good continuation. 
Each perceptual groups or groups designated by 
a gesture could be the base domain for an 
extraction. Referential expressions work the 
same way either the domains are discursive, 
perceptual or gestural, they extract and highlight 
referents in these domains. See (Landragin et al, 
2001) for a review of perceptual groupings.  
4 Basic Type 
A referential domain is defined by:  
? a set of entities accessible through this 
domain (ground of domain), 
? a description subsuming the description 
of all these entities (type of domain), 
? a set of access structures to these 
entities. 
For instance: ?the Ibis hotel (h1) and the hotel 
Lafayette (h2)? forms a referential domain, 
whose type would be Hotel, and whose 
accessible entities would be h1 and h2, 
themselves defined as domains of type Hotel. 
These two hotels could be accessed later on by 
their names. 
4.1 Access structures 
We suppose that the distinction between the 
referents from the excluded alternatives requires 
highlighting a discrimination criterion opposing 
them. This criterion behaves like a partition of 
the accessible entities, grouping them together 
according to their similarities and their 
differences. A partition may have one of its parts 
focused. There are, at least, three kinds of 
discrimination criteria: 
? discrimination on description. Entities 
can be discriminated by their type, their 
properties, or by the relations they have with 
other entities. For example the name of the 
hotels is a discrimination criterion in ?the Ibis 
hotel and the hotel Lafayette?. 
? discrimination on focus. Entities can 
also be discriminated by the focus they have 
when they are mentioned in the discourse or 
designed by a gesture. For example, ?this 
room? would select a focused referent in a 
domain, whereas ?the other room? would 
select a non-focused one. 
? discrimination on time of occurrence. 
Entities can finally be discriminated by their 
occurrence in the discourse. For example ?the 
second hotel? would discriminate this hotel 
by its rank in the domain. 
4.2 Classical resolution algorithm 
Each activated domain belongs to list of domains 
ordered along their recentness (the referential 
55
space).  The resolution algorithm consists of two 
phases: 
1. Searching a suitable, preferred domain in 
the referential space when interpreting a 
referring expression. The suitability is 
defined by the minimal conditions the domain 
has to conform to in order to be the base of an 
interpretation (particular description, or 
presence of a particular access structure with 
focus or not). The main preference factor is 
the minimization of the access cost 
(recentness or salience), however other 
criteria like thematic structure could be taken 
into account and will be future work. Each 
domain is tested according to the constraints 
given by the referential expression. We allow 
several layers of constraints for each type of 
expression : if the stronger constraints are not 
met, then weaker constraints are tried. 
2. Extracting a referent and restructuring the 
referential space, taking into account this 
extraction. It not only focuses the referent in 
its domain, but also moves the domain itself 
to a more recent place. When one referent 
acquires the focus, the alternative  members 
of the same partition loose it. 
This generic scheme is instantiated for each type 
of access modes (a modality plus an expression). 
For example a definite ?the N? will search for a 
domain in which a particular entity of type ?N? 
can be discriminated, and the restructuring 
consists in focalizing in this domain the referent 
found. See (Landragin & Romary, 2003) for a 
description of the different access modes. 
The algorithm highlights the two types of 
ambiguities, domain or referent ambiguities, 
which occur when there is no preference 
available to make a choice between multiples 
entities in the first or the second phase. We guess 
that natural ambiguities should eventually be 
solved through the dialogue between the agents 
of the communication.  
5 Super-Domains 
In order to take groupings into account in the 
Reference Domains Theory, we introduce two 
constructs in our formal toolbox. Indeed, having 
only one kind of domain construct doesn?t allow 
for a correct distinction between different 
referent statuses.  
First we distinguish plural and simple domains. 
The simple domains D serve as bases for 
profiling, or highlighting, a subpart, or related 
part of a simple referent. For instance, if D = 
Room, then one can profile a Price from D. The 
plural domains D* serve as either as a generic 
base or as a plural representative for profiling 
a simple domain D. A generic base is mandatory 
in our model to support the insertion of new 
extra-linguistic referents evoked with an 
indefinite construct (for instance ?I saw a black 
bird on the roof?), while plural representatives 
are used for explicit groupings. A domain D*1 
can also be profiled from a D*0, provided D*1 
profiles a subset of the elements of D*0. 
Second, we introduce the notion of super-
domain D+, from which a D* can be profiled. 
The relations allowed between domains are  
represented on figure 1. A super-domain D+ is 
the domain of all groupings D*, including a 
special D*all grouping which is the representative 
of all evoked instances of a given category. This 
configuration is not intended to deal with long 
dialogues where several, trans-sentential 
groupings occur, and where older groupings may 
become out of access. Doing this would require 
a rhetorically driven structuring of the D*all.  
 
Figure 1: Access structure of Reference 
Domains 
 
As Reference Domain Theory is primarily 
targeted toward extra-linguistic referents 
occurring in practical dialogue, the construction 
of the domain trees, representing the supposed 
structuring of referents accessibility, is based on 
ontology. As a consequence, for each ?natural? 
type and each subtype (for instance 
Room?Single), a domain tree is potentially 
created (actually, one can easily imagine how 
this creation may be driven ?on-demand?). 
Another evolution from the initial Reference 
Domain Theory is the possibility to focalize 
several items of a partition. Indeed, since the 
resolution algorithm can focalize a whole plural 
domain, all elements of this domain must be 
focalized in all the plural domains they occur in. 
In order to refer to plural entities the idea is to 
build plural domains dynamically : when some 
sentence-level grouping, either implicit or 
explicit occurs or when a plural extra-linguistic 
referent is evoked, a D* is created and focussed 
D+ 
D* D D* 
D+ : super-domain 
D* : plural domain 
D  : simple domain 
 
        : gives access to 
56
in D+, with each of its components as children, 
when possible (that is, when each component is 
described). When new extra-linguistic referents 
(singular or plural) are evoked, they are 
individually profiled under the D*all 
corresponding to their types (that is, their 
?natural? type, and all the subtypes they are 
eligible to). 
In short, for all referents of type D: 
? they become subdomains of D*all 
? if they are plural referents, they also build 
up a focalized subdomain of D+
 
?
 all the referents of a given type are then 
grouped together under a new focalized 
subdomain of D+.  
  Figure 2 illustrates the state of the Hotel+ 
domain tree after a scenario with three dialogue 
acts, the first one introducing Hotel1, the second 
one inserting a grouping of Hotel2 and Hotel3. 
and the third one referring to it.  
 
 
 
 
 
 
 
 
 
 
 
 
 
Figure 2: A domain tree built from a scenario 
above (focus in bold) 
The operations are the following : 
U1 : Hotel1 becomes a subdomain of Hotel*all 
which gains focus in Hotel+. 
S1 : Hotel2 and Hotel3 become subdomains of 
Hotel*all. In addition Hotel2 and Hotel3 are 
grouped in Hotel*1 which gains the focus in 
Hotel+ while Hotel*all loses it. 
U2 : The pronoun is solved in Hotel+, and Hotel*1 
is retrieved. 
One can see that Hotel*all is inaccessible by a  
generic expression like a demonstrative without 
modifiers but only by a special expression like 
"all the hotels". In our point of view, the reason 
is that the grouping Hotel*1 lowers the salience 
of Hotel*all. 
6 Implementation  
We used description logics for modelling 
domains and domain-reasoning. One has to deal 
with plural entities and can follow (Franconi, 93) 
by using collection theory, representing 
collections as individuals and membership by a 
role (plus plural quantifiers). But we should use 
another way considering that the inference 
engine we use, Racer (Haarslev and M?ller, 03), 
does not take into account ALCS. Hence we 
tried representing the domains by concepts, 
given their semantic are set of individuals. The 
domain D+ corresponds to the concept D, and 
the domain-subdomain relation is a 
subsumption. All basic manipulation with 
domains could be done using Tbox assertions. 
Additionnally, a partition structure is simply a 
sequence of subdomains which are different 
from each other (disjoint concepts) and whose 
elements could be focussed. The algorithm goes 
through the referential space and tests each 
domain in the recency order against the 
constraints given by the referential expression. 
Conceptual tests on the description and 
partitional tests on the focus or possible 
discriminations are made to retrieve the domain 
and the referent. If none are found, they may be 
created by accomodation. Groupings are created 
only for explicit coordinations, implicit 
sentential coordinations (two referents could be 
grouped if they have the same basic type) and 
some kind of specifications.  
Domains and groupings creation entails the 
creation of new concepts in the Tbox. Each 
concept insertion requires a costly 
reclassification, therefore we preferred an 
approximation considering only that new 
groupings assert primitive concepts. Other 
domains are concept terms i.e. descriptions 
which do not have to be asserted in the Tbox 
automatically. 
Implicit discursive groupings are not 
implemented considering the need of a rhetorical 
structure  (like in SDRT, Asher 93) or a mental 
space model. The following example shows the 
needs : 
 U1 : I would like an hotel (h1) 
 S1 : I propose you the hotel Ibis (h2) and 
 the Lafayette hotel (h3). 
Hotel h1 could very hardly be grouped with h2 
and h3, even by ?all these hotels? (or maybe by a 
third speaker). We guess among other factors 
that they belong to different levels of 
interpretation, h1 in the domain of the desires of 
Hotel+ 
Hotel*all Hotel*1 
Hotel1 Hotel2 Hotel3 
U1: The Ibis Hotel (Hotel1) is too expensive 
S1: Maybe the Hotel Lafayette (Hotel2) or 
the Hotel de la cloche (Hotel3) 
U2: Those hotels are too far from the airport. 
 
57
the user, and the others in the domain of existing 
hotels. The link between the two domains is 
possible if one knows that S1 is an answer of to 
U's request. Such discrimination criterion and 
high level domains are not yet implemented. 
Instead we concentrated on extra-linguistic 
referents which are assumed to be interpreted in 
the real/system world (like hotels, rooms). We 
are currently testing the approach to see if it 
could be extended to any type of entities 
provided accurate discrimination criteria (like 
the predication). 
7 Example 
A sample dialogue (table 1) is analyzed through 
the preceding algorithm. This example shows 
how the referents introduced in an explicit 
coordination could be referenced as a whole ?the 
two hotels?, or extracted discriminately by an 
ordinal ?the second one? or by an otherness 
expression ?the other one?. All the subdomains 
of H+ (i.e. the plural domains of hotels) are 
indicated after each interpretation using a 
simplified notation. Only the ordered list of 
accessible entities and their focalization (bold) 
are noted for each subdomain. For instance 
H*all= (h1, h2, h3) means that the domain H*all is 
focalized in H+, and that h3 is focalized in H*all. 
Table 1: Example of dialogue (focus in bold) 
 
In order to interpret U1, U2 or U3 one needs to 
rely on the previous structuring of H+. In U1, the 
previously focalized domain H*1 is preferred to 
be the base for interpreting ?the second one? 
because of the order discrimination. This leads 
to extracting h1 hence focalizing it in H*1 but 
also in H*0 and in H*all. In U2, H*1 cannot be the 
base for interpreting ?the third one? because no 
entity could be discriminate this way. Therefore 
the only suitable domain is H*all. It is also 
impossible to interpret U3 : ?the other one? in 
H*1 because of the lack of a focus discrimination 
between h1 and h2.  
It is however possible to choose H*all for the 
domain of interpretation: the excluded referents 
h1 and h2 are unfocused while h3 gains focus. 
 
8 Evaluation in progress 
This work is currently being evaluated in the 
MEDIA/EVALDA framework, a national 
understanding evaluation campaign. (Devillers et 
al., 04). It aims to evaluate the semantic and 
referential abilities of systems with various 
approaches of natural language processing. The 
results of each system are compared to manually 
annotated utterances transcribed from a Woz 
corpus in a hotel reservation task. For the 
referential facet, referential expressions 
(excluding indefinites, and proper names) are 
annotated by a semantic description of their 
referents. 
Our system which relies on a symbolic approach 
using deep parsing and description logics for 
semantic currently scores 64% (f-measure) for 
identifying and describing accurately the 
referents. We guess that such evaluation will be 
an occasion for us to test different hypothesis on  
reference resolution using domains (for exemple 
different criteria for grouping). However we do 
not have yet more precise results on plurals and 
ordinals specifically.  
9 Conclusion 
The extension we made to the Reference 
Domains Theory is still limited because it 
considers only extra-linguistic referents, i.e. 
those also having an existence outside discourse. 
In addition the trans-sentential groupings are not 
fully studied yet. We guess that such groupings 
should need a rhetorical description of the 
discourse or dialogue. In spite of its limits, the 
extension can render dynamic effects allowing 
ordinals and otherness in plural contexts. An 
Dialogue H+ 
U: Is there a bathroom at 
the Ibis hotel (h1) and the 
hotel Lafayette (h2)? 
H*0 = (h1, h2) 
H*all = (h1, h2) 
S: No they don't have 
bathrooms 
H*0 = (h1, h2) 
H*all = (h1, h2) 
S: But I propose you the 
Campanile hotel (h3) 
H*0 = (h1, h2) 
H*all = (h1, h2, h3) 
U: Hmm no, how much 
were the two hotels? 
H*0 = (h1, h2) 
H*all = (h1, h2, h3) 
S: The hotel Lafayette is 
100 euros, the Ibis hotel is 
75 euros 
H*1 = (h2, h1) 
H*0 = (h1, h2) 
H*all = (h1, h2, h3) 
U1: Ok, I take the second 
one 
H*1 = (h2, h1) 
H*0 = (h1, h2) 
H*all = (h1, h2, h3) 
U2: Ok, I take the third 
one 
U3 : and the other one ? 
H*1 = (h2, h1) 
H*0 = (h1, h2) 
H*all = (h1, h2, h3) 
58
implementation in description logics is  currently 
being evaluated in the MEDIA/EVALDA 
framework. 
References 
Nicholas Asher. 1993. Reference to Abstract Objects   
in English: A Philosophical Semantics for Natural 
Language Metaphysics. In Studies in Linguistics 
and Philosophy, Kluwer, Dordrecht. 
Laurence Devillers, H?l?ne Maynard, St?phanie 
Rosset, Patrice Paroubek, Kevin McTait, Djamel 
Mostefa, Khalid Choukri, Caroline Bousquet, 
Laurent Charnay, Nadine Vigouroux, Fr?d?ric 
B?chet, Laurent Romary, Jean-Yves Antoine, 
Jeanne Villaneau, Myriam Vergnes, and J?r?me 
Goulian. 2004. The French MEDIA/EVALDA 
Project : the Evaluation of the Understanding 
Capability of Spoken Language Dialog System. In 
Proceedings of LREC 2004, Lisbon, Portugal. 
Carola Eschenbach, Christopher Habel, Michael 
Herweg, Klaus Rehk?mper. 1989. Remarks on 
plural anaphora. In Proc. Fourth Conference of the 
European Chapter of the Association for 
Computational Linguistics. 
Enrico Franconi. 1993. A treatment of plurals and 
plural quantifications based on a theory of 
collections. Minds and Machines (3)4:453-474, 
Kluwer Academic Publishers, November 1993 
Petra Gieselmann: 2004. Reference Resolution 
Mechanisms in Dialogue Management. In: 
Proceedings of the Eighth Workshop on the 
Semantics and Pragmatics of Dialogue 
(CATALOG), Barcelona, 2004. 
Volker Haarslev, and Ralf M?ller. 2003. Racer: A 
Core Inference Engine for the Semantic Web. In 
Proceedings of the 2nd International Workshop on 
Evaluation of Ontology-based Tools (EON2003), 
located at the 2nd International Semantic Web 
Conference ISWC 2003, Sanibel Island, Florida, 
USA, October 20, 2003, pp. 27-36. 
Ashwani Kumar, Susanne Salmon-Alt, and Laurent 
Romary. 2003. Reference resolution as a 
facilitating process towards robust multimodal 
dialogue management: A cognitive grammar 
approach. In International Symposium on 
Reference Resolution and Its Application to 
Question Answering and Summarization. 
Fr?d?ric Landragin, and Laurent Romary. 2003. 
Referring to Objects Through Sub-Contexts in 
Multimodal Human-Computer Interaction. In Proc. 
Seventh Workshop on the Semantics and 
Pragmatics of Dialogue (DiaBruck'03), 
Saarbr?cken, Germany, 2003, pp. 67-74. 
Fr?d?ric Landragin, Nadia Bellalem and Laurent 
Romary. 2001. Visual Salience and Perceptual 
Grouping in Multimodal Interactivity. In: First 
International Workshop on Information 
Presentation and Natural Multimodal Dialogue, 
Verona, Italy, 2001 
David R. Olson. 1970. Language and Thought: 
Aspects of a Cognitive Theory of Semantics. 
Psychological Review, 77/4, 257-273. 
Susanne Salmon-alt. 2000. Interpreting referring 
expressions by restructuring context. Proc. ESSLLI 
2000, Student Session, Birmingham, UK, August 
2000. 
Susanne Salmon-Alt. 2001. Reference Resolution 
within the Framework of Cognitive Grammar. 
Proc. International Colloquium on Cognitive 
Science, San Sebastian, Spain 
Dan Sperber and Deirdre Wilson. 1986. Relevance, 
Communication and Cognition. Basil Blackwell, 
Oxford. 
59
Proceedings of the 3rd Workshop on Scalable Natural Language Understanding, pages 49?56,
New York City, June 2006. c?2006 Association for Computational Linguistics
Scaling Construction Grammar up to Production Systems:  the Situated Constructional Interpretation Model  Guillaume Pitel Langue et Dialogue LORIA BP239 54000 Nancy, France Guillaume.Pitel@gmail.com     
Abstract While a great effort has concerned the de-velopment of fully integrated modular un-derstanding systems, few researches have focused on the problem of unifying exist-ing linguistic formalisms with cognitive processing models. The Situated Construc-tional Interpretation Model is one of these attempts. In this model, the notion of ?con-struction? has been adapted in order to be able to mimic the behavior of Production Systems. The Construction Grammar ap-proach establishes a model of the relations between linguistic forms and meaning, by the mean of constructions. The latter can be considered as pairings from a topologically structured space to an unstructured space, in some way a special kind of production rules. 
1 Introduction Accounting for pragmatical and cognitive phe-nomena in a linguistic formalism is a challenging task whose resolution would be of great benefit for many fields of linguistics, especially those dealing with interpretation in a context. In domains such as practical dialogue or embodied understanding, there would be a real gain in dealing with envi-ronment data the same way one deals with linguis-tic data. These kinds of systems currently need ad hoc heuristics or representations. These heuristics 
are implemented in modules that are often impos-sible to reuse for another task than the one they were developed for. This point particularly con-cerns phenomena that lay at the interface of lin-guistics and general cognition, such as vagueness (Ballweg, 1983), reference resolution (Brown-Schmidt, 2003; Reboul, 1999), or modeling of cognitive representations (Langacker, 1983; Talmy, 1988). Similarly, accounting for linguistic phenomena in a psychologically motivated model is far from simple. The attempts in that direction are often limited to simple phenomena, because all linguistic formalisms rely on principles slightly or totally different from those of cognitive architectures.  The definitive solution to this problem is proba-bly still far from reach, but nevertheless, I think that the maturity of cognitive linguistics and the consequent emergence of language analyzers con-nected to cognitive architectures is an excellent direction toward a unified theory mixing linguistic and psychological models. The Embodied Con-struction Grammar or ECG (Bergen, 2003) and its analyzer (Bryant, 2003) are a good example of such an effort, even though it does not go beyond the linguistic layer since mental simulation is left to a mental simulation module based on the notion of x-schema (Narayanan, 2001). Consequently, I try to propose a model that con-ciliates a linguistic theory with a cognitive archi-tecture. The choice of the linguistic theory naturally goes to Construction Grammar (Fillmore, 1988; Kay 2002) and Frame Semantics (Fillmore, 1982), due to the parallel one can draw between a production rule and a construction, and the cogni-
49
tive architecture is, obviously, the family of Pro-duction Systems (Newell, 1990; Anderson, 1993). Moreover, since many pragmatical models rely on topologically structured representation, I introduce the notion of context, a notion that has never been adapted to these theories in order to organize data in ?storages? structured in dissimilar ways. 1.1 Typical Problem Consider a situation where a user can command a software to manipulate some very simple objects (colored geometrical objects of various sizes). The user may say (a) ?Put the small red square on the left?, (b) ?Remove the small red square on the left? or (c) ?Move the small red square on the left?. First, these three utterances may involve differ-ent parsing depending on the actual environment of the utterance, at least for those with ?put? and ?move?. Second, the ?square? targeted by the user may be a rectangle in the actual software represen-tation, with slightly different width and height. It may also be relatively small compared to other red squares, but bigger than other objects, and rela-tively red compared to other non-square objects. 
Imagine what happens in the different situations illustrated in Figure 1. In situation 1, for instance, (a) would not be understandable, since the small square is already on the left, while (c) could lead to the one argument sense of ?move?, i.e. ?move something somewhere else?, not to the two argu-ments version ?move something somewhere? (ac-tually, the one-argument sense is an implicit understanding of the destination allowed by ?move?, so the difference should not be lexical-ized). In situation 2, (b) and (c) would lead to two different interpretations of the referring expression ?the small red square on the left?: in (b), it refers to 
the square in the center (with a possible wavering), while it preferably refers to the square on the right in (c). In situation 3, (c) may be interpreted with the one argument sense of ?move?, and will target the square on the left since it is the smallest, but there should be a strong hesitation, since the other square is not that bigger, and the two arguments sense of ?move? is intuitively preferred. At the same time (a) will target the square on the right, which is relatively small compared to the neigh-boring circles, but would raise incomprehension if the circles were missing.  In general, in order to take those facts into ac-count, it is necessary either to produce all possible analyzes at each layer of the interpretation (which is quite problematic if it is desirable to allow for imperfect analyzes), or to allow two-ways interac-tions between the layers of interpretation (for in-stance, the pragmatic layer talking back to the semantic layer about the fact that the original posi-tion of an object is the same as the requested desti-nation, which may indicate a wrong analysis). My proposal is to allow for a generic capacity of interaction between the states of the interpretation (speaking about states is better than about layers since the latter presupposes something about the organizing of the interpretation), based on a unified operation between all the possible states. More specifically, the idea is to merge the notions from construction grammar and productions systems. 1.2 Merging Construction Grammar and Production Systems Merging a linguistic analyzer with a cognitive processing model may seem a bit useless since they do not share the same objective. Linguistic analyzer?s goal is to provide a formal model for the representation of linguistic knowledge, accordingly to linguistic observations. Cognitive models, on the other hand, aim at helping the modeling of real cognitive processing, in order to compare theoreti-cal model of perception processing with real data from experiments. Cognitive models like produc-tion systems being Turing-equivalent, they typi-cally do not lack of any expressiveness, meaning that anything one can describe with any linguistic representation could be implemented within a cog-nitive model (hopefully, since linguistic compe-tence is part of the cognitive competence). 
 Figure 1: Some situations involving different understandings (without color). 
50
However, to my knowledge, no attempt to try describing a linguistic competence within a cogni-tive model has gone a long way. Existing re-searches on that topic have focused on very narrow problems, and what is more important, have been tightened to very small lexicons (Emond, 1997; Ball, 2003; Fowles-Winkler and Michaelis, 2005). My analysis of this problem is that production systems are too permissive to allow a human to describe a grammar with a reasonable effort. More specifically, all generalization links that exist be-tween grammar rules should be encoded in some explicit way in a production system. Furthermore, linguistic formalisms are designed in such way to only express all possible human languages. In other words, a linguistic formalism is successful when it is flexible enough to describe all linguistic phenomena, while being human-readable enough to allow for a large-scale grammar devel-opment. As a consequence, linguistic formalisms are too restrictive to allow dealing with cognitive processes like the ones described using production systems. Putting together a linguistic formalism and a model of pragmatical and cognitive processing implies to make a choice among all the current theories. Given the large predominance of produc-tion systems in cognitive modeling, it seems quit-
natural to choose them as the cognitive model. The choice for the linguistic formalism is more open. Previous attempts of linguistic modeling in cogni-tive models have used 
? 
X  theory, categorical gram-mar or construction grammar. My pick has been the construction grammar because it shares some interesting features with production systems, and 
and because it deals directly with semantic, con-trary to other grammatical theories. Particularly, constructions are pairing between too poles: form and meaning, this is very similar to the notion of a production taking one input from a chunk, and producing its output into another one. 1.3 Example of processing In such an approach, what should happen when interpreting ?move the small square on the left? in situation 3 on the Figure 1?  The first step of the analysis (simplified for sake of clarity), illustrated in Figure 3, shows how ?move? produces a predi-cate that encompasses a Cause-Motion schema, itself evoking a Source-Path-Goal (SPG) and a Force-Action (FA) schema. The CxMove construc-tion adds a constraint about the fact that source and goal should differ. After this, two constructions CxImperative can connect, through their theme role, the referents evoked by the RefExp shemas (each construction being one possible interpretation) with the source of the Source-Path-Goal. The CxImperative encap-sulates the predicate in a Request schema. Another construction can connect the goal of the Source-Path-Goal with the Spatial-PP produced from ?on the left?, with the predicate modified by the con-struction that took its RefExp from ?the small square?.  At this point, the ?mental simulation? required  
to resolve the referents can start. This step is illus-trated in a very simplified way in Figure 2. The complete process is described in (Pitel, 2004; Pitel 
Figure 2: Mental simulation of the reference resolution  
Move the small square on the left 
Cause-Motion Ref-Exp Spatial-PP 
Ref-Exp 
CxMove CxRefExpSp CxSpatialPP 
Visual Context 
Resolution Context 1 
Resolution Context 2  
Figure 3: First step of analysis, the global construction (Imperative) is not active yet. 
SPG 
FA 
51
& Sansonnet, 2003) and processes potential refer-ents through several sorting steps, one for each referential predicate (here: square and small in Resolution Context 1 from the two-arguments move interpretation; square, small and on the left in Resolution Context 2 from the other one). The process is described with the kind of constructions defined by the SCIM.  2 Basic Notions of the SCIM The Situated Constructional Interpretation model (SCIM) describes how information can be proc-essed in a way that is both linguistically and psy-chologically plausible. It relies on three notions: schemas are for low-level data description, con-texts are for describing the organization of in-stances of schemas, and s-constructions represent the mean to process data. Eventually, a SCIM-based interpretation system will run instances of s-constructions that take and produce instances of schemas situated in instances of contexts. These three notions are partly inherited from the ECG. 2.1 Schemas Schemas are constrained, typed features struc-tures, with an inheritance mechanism and no type disjunction. Schemas are a kind of data type. They describe complex structures of information used to represent the state of the running interpretation. As shown in Figure 4, schemas are defined with three blocks: ? inherits schema-name1, ?  which specifies from which schema(s) this one inherits from. a specific case of the schema x, it inherits all of its properties (roles and constraints).  ? roles, which specifies a list of roles, con-strained to a given schema type or atomic type (Integer, Boolean, String, or user-defined enumerations of symbols).  ? constraints, which specify the constraints that must be verified in order for an instance of the schema to be a valid one. A constraint can be a predicate if the role has an atomic type, or an identification constraint (asserting that two roles must share the same value), or a filler constraint with a constant value. 
An instance of schema is moreover described by values attached to its roles (some or all of them may be left underspecified), a unique identifier, a positive value representing its informative capac-ity, a percentage of trust level, and the list of its parents? identifiers. A parent of an instance of schema is an instance of schema ?used? in the process that led to its production. It is thus possi-ble, in a s-construction, to know whether two given instances of schema are somehow related to each other in the interpretation process.   schema <schema-id> inherits <schema-id0, ..., schema-idn> Roles [?]<local-type-id>:<atomic-type-id> [?]<local-context-id>:<context-id>[@<local-context-id>] [?]<local-schema-id>:<schema-id>[@<local-context-id>] Constraints <boolean-operation>(<constraint0>, ..., <constraintn>) <role-id> ? <atomic-value>|<function>(<atomic-value>,?) <role-id> ? <role-id>|<C-function>(<role-id>) <role-id> = <role-id> <boolean-predicate>(<role-id0>, ..., <role-idn>)  a <role-id> is one of:    self (optional if not used alone)   <local-type-id>   <local-context-id>   <local-schema-id>   <inherited-schema>*<inherited-role-id>   <role-id>.<sub-role-id>  Figure 4: Schema definition formalism.  From the production systems perspective, sche-mas define the type of features that can be attached to a category. Basically, in that point of view, an instance of schema is a chunk and roles are slots. Schemas hierarchy  Schemas can inherit roles and constraints from other schemas. That means that schemas are orga-nized in a multiple inheritance hierarchy. In order to avoid ambiguity in role access, inherited roles must be accessed through an inheritance path. For instance, accessing the role color in a schema Square, if the hierarchy is Fig-ure?Rectangle?Square, and where the color role is declared in the Figure schema, would be realized through this kind of path: Rectangle*Figure*color. 
52
Inheritance also means that an instance of schema S can be unified with a role whose type is R if S == R or if R is one of the parents of S. One problem with this approach of inheritance is that, in order to fulfill the Liskov substitution prin-ciple (Liskov, 1988), it is sometimes necessary to use unnatural type hierarchies (stating that Square doesn?t inherit from Rectangle, for instance). I am very mindful about this problem, since such a dis-crepancy is quite tedious for a model that aims to approximate the human way of processing infor-mation, but this problem is out of the scope of this paper1. Constraints  A schema declaration contains a set of constraints that must be satisfied in order for an instance of this schema to be considered valid. Constraints are specified with six basic forms:   ? Type constraints on roles. ? Boolean operation (OR, NOT, NAND,?) connecting several constraints. ? Filler constraint symbolized by a single arrow (?) specifies that a constant, atomic value must fill the role in an instance.  ? Identification constraint, symbolized by a double-headed arrow (?), specifies that both sides of the constraint must unify, that is, all roles? values must be compatible with each other. ? An equality constraint (=) that constrains two roles to refer to the same instance. ? A boolean predicate constraint can be as-serted between any number of roles. Another kind of constraint, on the places occu-pied by instances of schema in context, will be ex-plained in the section about s-constructions, as will                                                            1 We consider that this problem could be solved by the ap-proach called ?Points of View Theory? (which is not related to inter-person points of view), proposed by Pitel (2004). In this theory, there is no type hierarchy, and the ability to substitute a representation by another is described by rules that can take the dynamic context into account. In this approach, types do not represent concepts, but points of view on perceptions (in the wide meaning), and transition from one point of view to the other is context-dependent. 
the role of interrogation marks in the schema dec-laration formalism.  2.2 Contexts A context declaration is a description of a container that can hold instances of schemas. In other words, it describes a space (including the topology part that can be specified by a set of relations and op-erations) that can contain pointers to instances of schemas at given places.  The notion of context inherits all of the proper-ties of the notion of schema. Actually, a context is really a kind of schema and, as a consequence, a schema?s role can be restricted to be a context.  A declaration of context adds three more blocks to the declaration of a schema, as shown in Figure 5: ? places declare a list of opaque types (the inter-nal structure of the type is hidden in the im-plementation) that describe an acceptable position in the context. Instances of schema (or context) that will be contained in an instance of this context will be linked with a position whose type is one (and only one) of the de-clared places. Examples of places are: point, segment, multi-segment, line, box, disc, ? context <context-id> inherits <context-id0, ..., context-idn> Roles   // idem schemas roles Constraints   // idem schemas constraints Places   <place-id> Relations   <relation-id(<place-id>, <place-id>,...)> ? <type-id>   // for instance: before(point, point) ? Boolean Operations   <operation-id>(<place-id>, <place-id>,...) ? <place-id>   // for instance: intersection(segment, segment) ? segment Figure 5: Context definition formalism  ? relations are functions that associate a value in an atomic domain from one or more places. Relations define constraints on the positions of a set of instances of schema. For instance, one can define a precedence relation in a linear context. 
53
? operations are functions that associate a posi-tion from one or more positions. For instance, a union of segments is an operation. Terminologically, an instance of schema (or context) located in a context, that is, an instance with a place, will be called a situated instance, whereas an instance of schema (or context) simply connected to another instance by a role will just be called a role instance. The only explicit equivalent to contexts in ECG is the notion of space, which describes Fau-connier's mental spaces (Fauconnier, 1985). Im-plicit contexts are however used in Construction Grammar: the form pole, which stores instances of schemas representing linguistic data in a linear space, and the unstructured meaning pole.  s-construction <s-construction-id> inherits <s-construction-id0, ?, s-construction-idn> roles // idem schema's roles constructional   <local-s-constr-id>: <s-construction-id> constituents   <local-ctx-id>: <context-id>[@<local-ctx-id>]/I|O|IO   <local-constit-id>: <schema-id>[@<local-ctx-id>]/I|O|IO constraints   // idem schemas constraints, plus :   // a role-id can be marked as muted: ?<role-id>   // a place-id is either a <local-constit-id> or the result of a context operation like:   // <local-ctx-id>.<context-operation-id>(<place-id>, ...)   <role-id> ?  <role-id> // right hand side must be parent   <local-ctx-id>.<context-relation-id>(<place-id>, ...)   OUT(<local-constit-id>) // remove the situated instance Figure 6: S-construction definition formalism 2.3 S-constructions S-constructions are situated constructions, that is, constructions that describe the relations between several instances of schemas located in structured contexts. As for the notion of context, the notion of s-construction is derived from the schemas, be-cause the s-construction itself can hold informa-tion. Besides that, the declaration of a s-construction contains: ? A constructional block that describes the other instances of s-constructions this s-construction relies on. The block contains a list of label: s-construction-name declara-tions. Any restriction on the constituents of 
those instances of s-construction is de-scribed as a constraint on label.constituent in the constraints block.   ? A constituents block that describes the in-stances of contexts and schemas constrained by the s-construction (note that the meaning of constituents is different than in ECG). The declaration of those constituents speci-fies whether the instance must preexist and/or whether it may be created or speci-fied by the s-construction?s constraints. From a production system point of view, it means that we describe which instances are in the input, and which one are produced.  S-constructions hierarchy  Like schemas, s-constructions are organized in a multiple inheritance hierarchy. Moreover, s-constructions benefit from a mechanism of con-structional dependence, held by the constructional block. Those two notions are, to some extent, re-dundant. Indeed, inheriting from a s-construction is equivalent to having an instance of this s-construction in the constructional block. However, one can have two different instances of the same s-construction in the constructional block, whereas it is impossible to inherit twice from the same s-construction. Moreover, it is possible to add a negative semantics in the constructional block, in order to assert that some instance of s-construction must not have occurred to satisfy the s-construction?s conditions. The constructional block is thus more powerful than the classical inheritance relation, but as for the schemas hierarchy, it is not within the scope of this paper to discuss about the inheritance relations be-tween s-constructions. A declaration of s-construction is thus, from that point of view, in conformance with the standard view shared in con-struction grammars. Situated aspects of s-constructions  A s-construction can ?choose? instances of sche-mas, given positional constraints in the context where the instances of schemas are stored. Then, the s-construction will ?create? new instances of context or schemas, or will specify some previ-ously underspecified role?s value. S-constructions 
54
can connect together more than two instances of schema. To that extent, it differs from ECG's con-struction (ECG's way of doing so makes use of an evoke block).  The specification of structural constraints is very similar to the other constraints. A structural con-straint looks like this: context-id.relation(roles-in-context-id). Basically, a context relation is consid-ered as a boolean predicate constraint. The main difference is that, instead of specifying the roles, such a constraint specifies the place of the instance of schema referred to by the role.  Dynamic aspects The biggest gap between productions systems and construction grammar is the difference between the dynamic nature of productions versus the declara-tive nature of linguistic constructions. For instance, a typical rule in a production system (from the ACT-R tutorial) would be represented in Figure 7. In order to take this possibility into account, it is necessary to introduce at some point some impera-tive features in the s-construction. Imperative features are introduced through sev-eral mechanisms. The first one is about role in-stances, the second one is about situated instances and the third one is about specifying constituents acting as inputs and/or outputs.   ACT-R declaration English description (p start      =goal> If the goal is  ISA count-from  to count from  start =num1  the number =num1  step start  and the step is start ==> Then    =goal>  change the goal  step counting  to note that one is now counting    +retrieval>  and request a retrieval  ISA count-order  of a count-order fact  first =num1  for the number that follows =num1 )  Figure 7: Example of ACT-R rule with a value changing ? Mutable roles. In the roles blocks, they are specified by a question mark (?).  If a role is marked as mutable in a schema declaration, then it can be accessed through two means in a s-construction constraint. The usual way con-strains the state of the role instance before the 
application of the s-construction, the mutated way constrains the state of the role instance af-ter the application of the s-construction. ? Removable situated instances. The constraint OUT(<constituent-id>) specifies that the situ-ated instance must be marked as not being pre-sent anymore in its context, after execution of the s-construction. ?  Input and/or output constituents. Each con-stituent of a s-construction is marked with a symbol /I or /O, stating whether the situated instance should be present before and whether it will be modified. 
3 Computational Aspects Given the characteristics of the SCIM, its expres-siveness and its procedural orientation, one cannot occult the problems that it raises from the compu-tational point of view.  Building an implementation of the Situated Constructional Interpretation Model definitely means to give up the idea of conducting a complete exploration of the search space. The main problem is that two s-constructions may lead to contradictory constraints. In other words, one must keep track of all the decisions and explore all the possibilities. The problem is even worse with mutable in-stances, since some constraints may be satisfied at some moment in one possible interpretation, while being unsatisfied at another moment. This time dependence must be handled very carefully, and adds some complexity to the processing of con-straints. However, the model also presents some interest-ing features, computationally speaking. For in-stance, it is quite easy to add a weighting layer to the SCIM, in order to simulate expectation, infor-mational potential, or execution cost. Such a layer could be trained to learn how to lead to the best interpretations at a minimal cost. 4 Conclusion In this paper I propose and describe a model of interpretation both linguistically and psychologi-cally motivated. This model allows describing a construction grammar as well as a production sys-tem, with three basic notions: schemas, contexts 
55
and s-constructions. Applications for such a model are wide, from more integrated dialogue systems to a unified theory of cognition and language.  A longer description of the processing architec-ture would be necessary in order to really confront the hypotheses I made in the section ?Computa-tional aspects?, but nevertheless, one can already draw a parallel between this model with a spatial structuring of information, and the structure that neuromimetic models can handle. Also, incomplete exploration of the search space, guided by a cost/gain approach, has previously been proposed as a plausible model of processing for human cog-nition. More than computational efficiency, the goal of this model is to propose a formalism that would be easier to use both for linguistic and cog-nitive modeling, in order to observe and act on the simulated processing of language and other cogni-tive functions. Many of the claims in this paper have yet to be proved through the implementation of the SCIM, and cognitive modeling using the system. Since many processing models have been made both on construction grammar and production systems, important researches should be easy enough to re-use in the SCIM.  References John R. Anderson (1993). Rules of the Mind. Erlbaum, Hillsdale, NJ. Jerry T. Ball (2003). Beginnings of a language compre-hension module in ACT-R 5.0. In F. Detje, D. Do-erner, & H. Schaub (Eds.), In Proceedings of the Fifth International Conference on Cognitive Model-ing (pp. 231-232). Bamberg, Germany: Universitats-Verlag Bamberg. Joachim Ballweg (1983). Vagueness or context-dependence? supervaluation revisited in a semantics based on scales. In T. T. Ballmer and M. Pinkal, edi-tors, Approaching Vagueness, pages 59--78. North Holland, Amsterdam. Benjamin K. Bergen & Nancy Chang (2003). Embodied construction grammar in simulation-based language understanding. In J.-O. Ostman and M. Fried, editors, Construction Grammar(s): Cognitive and Cross-Language Dimensions. John Benjamins, Sarah Brown-Schmidt & Michael K. Tanenhaus (2003). Referential domains and the interpretation of refer-ring expressions in interactive conversation. In Proc. 
of Diabruck 2003, Seventh Workshop on the Seman-tics and Pragmatics of Dialogue (SEMDIAL). Johno Bryant (2003). Constructional analysis. Master's thesis, University of California at Berkeley, Bruno Emond (1997). Modeling natural language com-prehension and anaphora resolution with ACT-R. In Proceedings of the Fourth Annual ACT-R Workshop (pp. 1-8). Pittsburgh, PA: Department of Psychology, Carnegie Mellon University. Fauconnier, G.  (1985). Mental Spaces: Aspects of Meaning Construction in Natural Language. MIT Press/Bradford, Cambridge, Mass. and London. Fillmore, C. J. (1982). Frame Semantics. In L. S. of Korea, editor, Linguistic in the Morning Calm, pages 111--38. Hanshin, Seoul. Fillmore, C. J. (1988). The Mechanisms of Construction Grammar. Berkeley Linguistics Society, 14:0 35?55. Anna M. Fowles-Winkler & Laura Michaelis (2005) An ACT-R model of sentence sorting with argument structure constuctions. In the Proceedings of the Lin-guistic Society of America Annual Meeting, January 7, 2005, Oakland, CA. Kay, P. (2002). An informal sketch of a formal architec-ture for construction grammar. Grammars, 5:0 1?19.  Langacker, R. W. (1987). Foundations of Cognitive Grammar, volume 1. Stanford University Press. Liskov, B.  (1988). Data abstraction and hierarchy. SIGPLAN Notices, 230 (5), 1988. Newell, A. (1990). Unified Theories of Cognition. Har-vard University Press, Cambridge, MA. Pitel, G. and Sansonnet, J.-P. (2003) Unified Represen-tation of Typological, Absolute and Relational Predi-cates. In Proceedings of PACLING?03. Avail. on first author web page. Pitel, G. (2004). MICO: la notion de construction situ?e pour un mod?le d?interpr?tation et de r?solution de la r?ference pour le dialogue finalis?. PhD Thesis, Uni-versit? Paris XI.  Reboul, A. (1999). Reference, agreement, evolving ref-erence and the theory of mental representation. In M. Coene, W. D. Mulder, P. Dendale, and Y. D'Hulst, Eds. Studia Linguisticae in honorem Lil-ianae Tasmowski, pages 601?616. Unipress, Pa-dova. Talmy, L. (1988).  Force dynamics in language and cognition. Cognitive Science, 12:0 49?100. 
56
